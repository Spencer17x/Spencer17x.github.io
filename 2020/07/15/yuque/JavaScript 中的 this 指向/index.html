<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JavaScript 中的 this 指向 - spencer17x</title><meta description="原文地址：https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;getify&amp;#x2F;You-Dont-Know-JS&amp;#x2F;blob&amp;#x2F;1ed-zh-CN&amp;#x2F;this%20%26%20object%20prototypes&amp;#x2F;ch2.md#%E4%BB%85%E4%BB%85%E6%98%AF%E8%A7%84%E5%88%99 首先关于 this 指向的问题，其实可以简单的理解为在哪里调用函数，其 this 指向就指向谁(箭头函"><meta property="og:type" content="blog"><meta property="og:title" content="JavaScript 中的 this 指向"><meta property="og:url" content="http://yoursite.com/2020/07/15/yuque/JavaScript%20%E4%B8%AD%E7%9A%84%20this%20%E6%8C%87%E5%90%91/"><meta property="og:site_name" content="spencer17x"><meta property="og:description" content="原文地址：https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;getify&amp;#x2F;You-Dont-Know-JS&amp;#x2F;blob&amp;#x2F;1ed-zh-CN&amp;#x2F;this%20%26%20object%20prototypes&amp;#x2F;ch2.md#%E4%BB%85%E4%BB%85%E6%98%AF%E8%A7%84%E5%88%99 首先关于 this 指向的问题，其实可以简单的理解为在哪里调用函数，其 this 指向就指向谁(箭头函"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://yoursite.com/img/og_image.png"><meta property="article:published_time" content="2020-07-15T02:14:21.000Z"><meta property="article:modified_time" content="2020-07-25T02:22:22.689Z"><meta property="article:author" content="spencer17x"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2020/07/15/yuque/JavaScript%20%E4%B8%AD%E7%9A%84%20this%20%E6%8C%87%E5%90%91/"},"headline":"spencer17x","image":["http://yoursite.com/img/og_image.png"],"datePublished":"2020-07-15T02:14:21.000Z","dateModified":"2020-07-25T02:22:22.689Z","author":{"@type":"Person","name":"spencer17x"},"description":"原文地址：https:&#x2F;&#x2F;github.com&#x2F;getify&#x2F;You-Dont-Know-JS&#x2F;blob&#x2F;1ed-zh-CN&#x2F;this%20%26%20object%20prototypes&#x2F;ch2.md#%E4%BB%85%E4%BB%85%E6%98%AF%E8%A7%84%E5%88%99 首先关于 this 指向的问题，其实可以简单的理解为在哪里调用函数，其 this 指向就指向谁(箭头函"}</script><link rel="canonical" href="http://yoursite.com/2020/07/15/yuque/JavaScript%20%E4%B8%AD%E7%9A%84%20this%20%E6%8C%87%E5%90%91/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="spencer17x" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Spencer17x"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-07-15T02:14:21.000Z" title="2020-07-15T02:14:21.000Z">2020-07-15</time><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BBYDKJS/">读YDKJS</a></span><span class="level-item">20 分钟 读完 (大约 3031 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">JavaScript 中的 this 指向</h1><div class="content"><p>原文地址：<a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20%26%20object%20prototypes/ch2.md#%E4%BB%85%E4%BB%85%E6%98%AF%E8%A7%84%E5%88%99">https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20%26%20object%20prototypes/ch2.md#%E4%BB%85%E4%BB%85%E6%98%AF%E8%A7%84%E5%88%99</a></p>
<p>首先关于 this 指向的问题，其实可以简单的理解为在哪里调用函数，其 this 指向就指向谁(箭头函数除外)。所以我们必须得理解调用点(即函数在代码中被调用的位置而不是被声明的位置)。</p>
<p>在 JavaScript 中，在你编写完代码，当引擎执行之前会进行预编译(也可以称为解析)，然后会形成对应的作用域。</p>
<p>在你声明函数的时候就确定作用域的称之为词法作用域，即为编译器对词法进行分析然后形成的作用域。这适用于大部分情况，然后 this 的表现形式与词法作用域不同，因为其是在被调用的时候确定其值，所以可以将其形成的作用域称为动态作用域。关于作用域可见：<a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20%26%20closures/ch1.md">https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20%26%20closures/ch1.md</a></p>
<p>接下来对 this 指向进行分类讨论：</p>
<h1 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h1><h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><p>我们要考察的第一种规则源于函数调用的最常见的情况：独立函数调用。可以认为这种 <code>this</code> 规则是在没有其他规则适用时的默认规则。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>当 foo() 被调用时， 此时方法调用 this 实施了默认绑定，所以 this 指向全局对象(strict 模式下指向 undefined)。</p>
<p>在该代码片段中，foo() 是被一个直白且毫无修饰的函数引用调用的，没有其他的我们将要展示的规则适用于这里。</p>
<p>简单来说，就是此书的 foo() 是直接执行，所以其 this 指向是默认指向 window 对象的。</p>
<p>一个微妙但是重要的细节是：即便所有的 <code>this</code> 绑定规则都是完全基于调用点的，但如果 <code>foo()</code> 的 <strong>内容</strong> 没有在 <code>strict mode</code> 下执行，对于 <em>默认绑定</em> 来说全局对象是 <strong>唯一</strong> 合法的；<code>foo()</code> 的调用点的 <code>strict mode</code> 状态与此无关。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line"></span><br><span class="line">  foo(); <span class="comment">// 2</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 在你的代码中故意混用 <code>strict mode</code> 和非 <code>strict mode</code> 通常是让人皱眉头的。你的程序整体可能应当不是 <strong>Strict</strong> 就是 <strong>非 Strict</strong>。然而，有时你可能会引用与你的 <strong>Strict</strong> 模式不同的第三方包，所以对这些微妙的兼容性细节要多加小心。</p>
<h2 id="隐含绑定"><a href="#隐含绑定" class="headerlink" title="隐含绑定"></a>隐含绑定</h2><p>另一种要考虑的规则是：调用点是否有一个环境对象（context object），也称为拥有者（owning）或容器（containing）对象，虽然这些名词可能有些误导人。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>首先，注意 <code>foo()</code> 被声明然后作为引用属性添加到 <code>obj</code> 上的方式。无论 <code>foo()</code> 是否一开始就在 <code>obj</code> 上被声明，还是后来作为引用添加（如上面代码所示），这个 <strong>函数</strong> 都不被 <code>obj</code> 所真正“拥有”或“包含”。</p>
<p>然而，调用点 <em>使用</em> <code>obj</code> 环境来 <strong>引用</strong> 函数，所以你 <em>可以说</em> <code>obj</code> 对象在函数被调用的时间点上“拥有”或“包含”这个 <strong>函数引用</strong>。</p>
<p>不论你怎样称呼这个模式，在 <code>foo()</code> 被调用的位置上，它被冠以一个指向 <code>obj</code> 的对象引用。当一个方法引用存在一个环境对象时，<em>隐含绑定</em> 规则会说：是这个对象应当被用于这个函数调用的 <code>this</code> 绑定。</p>
<p>因为 <code>obj</code> 是 <code>foo()</code> 调用的 <code>this</code>，所以 <code>this.a</code> 就是 <code>obj.a</code> 的同义词。<br>只有对象属性引用链的最后一层是影响调用点的。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">42</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  obj2: obj2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.obj2.foo(); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<h3 id="隐含丢失"><a href="#隐含丢失" class="headerlink" title="隐含丢失"></a>隐含丢失</h3><p><code>this</code> 绑定最常让人沮丧的事情之一，就是当一个 <em>隐含绑定</em> 丢失了它的绑定，这通常意味着它会退回到 _默认绑定_， 根据 <code>strict mode</code> 的状态，其结果不是全局对象就是 <code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数引用！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// `a` 也是一个全局对象的属性</span></span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// "oops, global"</span></span><br></pre></td></tr></table></figure>

<p>尽管 <code>bar</code> 似乎是 <code>obj.foo</code> 的引用，但实际上它只是另一个 <code>foo</code> 本身的引用而已。另外，起作用的调用点是 <code>bar()</code>，一个直白，毫无修饰的调用，因此 <em>默认绑定</em> 适用于这里。</p>
<p>这种情况发生的更加微妙，更常见，而且更意外的方式，是当我们考虑传递一个回调函数时：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// `fn` 只不过 `foo` 的另一个引用</span></span><br><span class="line"></span><br><span class="line">  fn(); <span class="comment">// &lt;-- 调用点!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// `a` 也是一个全局对象的属性</span></span><br><span class="line"></span><br><span class="line">doFoo(obj.foo); <span class="comment">// "oops, global"</span></span><br></pre></td></tr></table></figure>

<p>参数传递仅仅是一种隐含的赋值，而且因为我们在传递一个函数，它是一个隐含的引用赋值，所以最终结果和我们前一个代码段一样。</p>
<p>那么如果接收你所传递回调的函数不是你的，而是语言内建的呢？没有区别，同样的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// `a` 也是一个全局对象的属性</span></span><br><span class="line"></span><br><span class="line">setTimeout(obj.foo, <span class="number">100</span>); <span class="comment">// "oops, global"</span></span><br></pre></td></tr></table></figure>

<p>正如我们刚刚看到的，我们的回调函数丢掉他们的 <code>this</code> 绑定是十分常见的事情。但是 <code>this</code> 使我们吃惊的另一种方式是，接收我们回调的函数故意改变调用的 <code>this</code>。那些很流行的 JavaScript 库中的事件处理器就十分喜欢强制你的回调的 <code>this</code> 指向触发事件的 DOM 元素。虽然有时这很有用，但其他时候这简直能气死人。不幸的是，这些工具很少给你选择。</p>
<p>不管哪一种意外改变 <code>this</code> 的方式，你都不能真正地控制你的回调函数引用将如何被执行，所以你（还）没有办法控制调用点给你一个故意的绑定。我们很快就会看到一个方法，通过 <em>固定</em> <code>this</code> 来解决这个问题。</p>
<h2 id="明确绑定"><a href="#明确绑定" class="headerlink" title="明确绑定"></a>明确绑定</h2><p>即使用 call 或者 apply 显示绑定 this 的指向，而通过 bind 来绑定的称之为硬绑定，call、apply、bind 这种明确的给 this 进行的绑定我们都称之为明确绑定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logThis</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"this"</span>, <span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"args"</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logThis.call(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">logThis.apply(&#123; <span class="attr">a</span>: <span class="number">2</span> &#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> bindLogThis = logThis.bind(&#123; <span class="attr">a</span>: <span class="number">3</span> &#125;, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">bindLogThis(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 在 ES6 中，<code>bind(..)</code> 生成的硬绑定函数有一个名为 <code>.name</code> 的属性，它源自于原始的 _目标函数（target function）_。举例来说：<code>bar = foo.bind(..)</code> 应该会有一个 <code>bar.name</code> 属性，它的值为 <code>&quot;bound foo&quot;</code>，这个值应当会显示在调用栈轨迹的函数调用名称中。</p>
<h3 id="API-调用的“环境”"><a href="#API-调用的“环境”" class="headerlink" title="API 调用的“环境”"></a>API 调用的“环境”</h3><p>确实，许多库中的函数，和许多在 JavaScript 语言以及宿主环境中的内建函数，都提供一个可选参数，通常称为“环境（context）”，这种设计作为一种替代方案来确保你的回调函数使用特定的 <code>this</code> 而不必非得使用 <code>bind(..)</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(el, <span class="keyword">this</span>.id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  id: <span class="string">"awesome"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `obj` 作为 `this` 来调用 `foo(..)`</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(foo, obj); <span class="comment">// 1 awesome  2 awesome  3 awesome</span></span><br></pre></td></tr></table></figure>

<p>从内部来说，几乎可以确定这种类型的函数是通过 <code>call(..)</code> 或 <code>apply(..)</code> 来使用 <em>明确绑定</em> 以节省你的麻烦。</p>
<h2 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h2><p>这个很简单，就是通过实例化一个 constructor，那么该构造函数的 this 指向该实例化的对象。</p>
<p>当在函数前面被加入 <code>new</code> 调用时，也就是构造器调用时，下面这些事情会自动完成：</p>
<ol>
<li>一个全新的对象会凭空创建（就是被构建）</li>
<li><em>这个新构建的对象会被接入原形链（<code>[[Prototype]]</code>-linked）</em></li>
<li>这个新构建的对象被设置为函数调用的 <code>this</code> 绑定</li>
<li>除非函数返回一个它自己的其他 <strong>对象</strong>，否则这个被 <code>new</code> 调用的函数将 <em>自动</em> 返回这个新构建的对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar.a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>很显然，<em>默认绑定</em> 在四种规则中优先权最低的。所以我们先把它放在一边。</p>
<p><em>隐含绑定</em>  和  <em>明确绑定对比：</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo(); <span class="comment">// 2</span></span><br><span class="line">obj2.foo(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2); <span class="comment">// 3</span></span><br><span class="line">obj2.foo.call(obj1); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>所以, <em>明确绑定</em> 的优先权要高于 <em>隐含绑定_，这意味着你应当在考察 _隐含绑定</em> 之前 <strong>首先</strong> 考察 <em>明确绑定</em> 是否适用。</p>
<p>现在，我们只需要搞清楚 <em>new 绑定</em> 的优先级位于何处。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.a); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj1.foo(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.a); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>好了，<em>new 绑定</em> 的优先级要高于 <em>隐含绑定_。那么你觉得 _new 绑定</em> 的优先级较之于 <em>明确绑定</em> 是高还是低呢？</p>
<p><strong>注意：</strong> <code>new</code> 和 <code>call</code>/<code>apply</code> 不能同时使用，所以 <code>new foo.call(obj1)</code> 是不允许的，也就是不能直接对比测试 <em>new 绑定</em> 和 <em>明确绑定_。但是我们依然可以使用 _硬绑定</em> 来测试这两个规则的优先级。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(obj1);</span><br><span class="line">bar(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(baz.a); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p><code>bar</code> 是硬绑定到 <code>obj1</code> 的，但是 <code>new bar(3)</code> 并 <strong>没有</strong> 像我们期待的那样将 <code>obj1.a</code> 变为 <code>3</code>。反而，<em>硬绑定_（到 <code>obj1</code>）的 <code>bar(..)</code> 调用 _<strong>可以</strong></em> 被 <code>new</code> 所覆盖。因为 <code>new</code> 被实施，我们得到一个名为 <code>baz</code> 的新创建的对象，而且我们确实看到 <code>baz.a</code> 的值为 <code>3</code>。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>现在，我们可以按照优先顺序来总结一下从函数调用的调用点来判定 <code>this</code> 的规则了。按照这个顺序来问问题，然后在第一个规则适用的地方停下。</p>
<ol>
<li><p>函数是通过 <code>new</code> 被调用的吗（<strong>new 绑定</strong>）？如果是，<code>this</code> 就是新构建的对象。<br><code>var bar = new foo()</code></p>
</li>
<li><p>函数是通过 <code>call</code> 或 <code>apply</code> 被调用（<strong>明确绑定</strong>），甚至是隐藏在 <code>bind</code> <em>硬绑定</em> 之中吗？如果是，<code>this</code> 就是那个被明确指定的对象。<br><code>var bar = foo.call( obj2 )</code></p>
</li>
<li><p>函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（<strong>隐含绑定</strong>）？如果是，<code>this</code> 就是那个环境对象。<br><code>var bar = obj1.foo()</code></p>
</li>
<li><p>否则，使用默认的 <code>this</code>（<strong>默认绑定</strong>）。如果在 <code>strict mode</code> 下，就是 <code>undefined</code>，否则是 <code>global</code> 对象。<br><code>var bar = foo()</code></p>
</li>
</ol>
<p>注意：箭头函数的 this 指向其父级作用域的 this 的指向，箭头函数使用词法作用域来决定 this 绑定，这意味着它们采用封闭他们的函数调用作为  <code>this</code>  绑定（无论它是什么）。它们实质上是 ES6 之前的  <code>self = this</code>  代码的语法替代品。</p>
</div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/07/17/yuque/%E8%AF%BBYDKJS/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">读YDKJS</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/07/04/yuque/%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%B8%8B%E6%8B%89%E6%9F%A5%E7%9C%8B%E7%BD%91%E5%9D%80/"><span class="level-item">微信浏览器中如何阻止下拉查看网址</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: '6361712f53c7e3396c48a150b48014fc',
            repo: 'Spencer17x.github.io',
            owner: 'Spencer17x',
            clientID: '93bb3cef0ddefdb2554f',
            clientSecret: '9937a7370c6782ded33c773d2ec69fde49172071',
            admin: ["Spencer17x"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: 'last',
            
            
            enableHotKey: true
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://avatars1.githubusercontent.com/u/32794413?s=460&amp;u=3375fb02360ec8d527c80a4e819cde67387d8cfb&amp;v=4" alt="spencer17x"></figure><p class="title is-size-4 is-block line-height-inherit">spencer17x</p><p class="is-size-6 is-block">Front-end</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Hangzhou</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">51</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">1</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Spencer17x" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Spencer17x"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%BBYDKJS/"><span class="level-start"><span class="level-item">读YDKJS</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-17T06:34:55.000Z">2020-07-17</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/17/yuque/%E5%91%BD%E5%90%8D%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%20VS%20%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/">命名函数表达式 VS 匿名函数表达式</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E8%AF%BBYDKJS/">读YDKJS</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-17T06:33:01.000Z">2020-07-17</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/17/yuque/%E8%AF%BBYDKJS/">读YDKJS</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-15T02:14:21.000Z">2020-07-15</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/15/yuque/JavaScript%20%E4%B8%AD%E7%9A%84%20this%20%E6%8C%87%E5%90%91/">JavaScript 中的 this 指向</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E8%AF%BBYDKJS/">读YDKJS</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-04T14:38:57.000Z">2020-07-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/04/yuque/%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%B8%8B%E6%8B%89%E6%9F%A5%E7%9C%8B%E7%BD%91%E5%9D%80/">微信浏览器中如何阻止下拉查看网址</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-04T14:36:13.000Z">2020-07-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/04/yuque/%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB%E8%B8%A9%E5%9D%91%E6%B1%87%E6%80%BB/">微信分享踩坑汇总</a></p><p class="is-uppercase"></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"><span class="tag">未完成</span><span class="tag is-grey-lightest">6</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="spencer17x" height="28"></a><p class="size-small"><span>&copy; 2020 spencer17x</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>