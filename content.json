{"pages":[],"posts":[{"title":"H5微信共享地址(获取用户地址信息)","text":"可参考文档: https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115, 共享收获地址接口 在开发的时候，发现引入 JSSDK 后，安卓正常，IOS 却失败。 解决方法：JSSDK 应改为 https://res.wx.qq.com/open/js/jweixin-1.1.0.js 使用方法: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647getWxLocation(cb, errCb) { axios.get(\"/api/xcx_sdk_signature?url=\" + encodeURIComponent(location.href.split('#')[0])).then(function (res) { if (res.code == 20000) { // 接口请求正常 wx.config({ debug: false, appId: res.data.appId, timestamp: res.data.timestamp, nonceStr: res.data.nonceStr, signature: res.data.signature, jsApiList: ['checkJsApi', 'openAddress'] }); wx.ready(function () { wx.checkJsApi({ jsApiList: [ 'openAddress', ], success: function (res) { alert(JSON.stringify(res)); } }); wx.openAddress({ trigger: function (res) { alert('用户开始拉出地址'); alert(JSON.stringify(res)); }, success: function (res) { // 返回值看下面 cb(res); }, cancel: function (res) { alert('用户取消拉出地址'); }, fail: function (res) { alert(JSON.stringify(res)); } }); }); wx.error(function (res) { alert(JSON.stringify(res)); }); } else { alert(res.errMsg); } }).catch(function (error) { alert(error); });} 返回说明 返回值 说明 errMsg 获取编辑收货地址成功返回“openAddress:ok”。 userName 收货人姓名。 postalCode 邮编。 provinceName 国标收货地址第一级地址（省）。 cityName 国标收货地址第二级地址（市）。 countryName 国标收货地址第三级地址（国家）。 detailInfo 详细收货地址信息。 nationalCode 收货地址国家码。 telNumber 收货人手机号码。","link":"/2020/07/04/yuque/H5%E5%BE%AE%E4%BF%A1%E5%85%B1%E4%BA%AB%E5%9C%B0%E5%9D%80(%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF)/"},{"title":"CSS 盒模型","text":"MDN 对 CSS 盒模型的介绍**当对一个文档进行布局（lay out）的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子（box）。CSS 决定这些盒子的大小、位置以及属性（例如颜色、背景、边框尺寸…）。 每个盒子由四个部分（或称区域）组成，其效用由它们各自的边界（Edge）所定义（原文：defined by their respective edges，可能意指容纳、包含、限制等）。如图，与盒子的四个组成区域相对应，每个盒子有四个边界：内容边界 Content edge、内边距边界 Padding Edge、边框边界 Border Edge、外边框边界 Margin Edge。 Margin(外边距) - 清除边框外的区域，外边距是透明的。Border(边框) - 围绕在内边距和内容外的边框。Padding(内边距) - 清除内容周围的区域，内边距是透明的。Content(内容) - 盒子的内容，显示文本和图像。 元素的宽度和高度当您指定一个 CSS 元素的宽度和高度属性时，你只是设置内容区域的宽度和高度。要知道，完全大小的元素，你还必须添加填充，边框和边距。 举例1234567// 总宽度为250像素的元素div { width: 220px; padding: 10px; border: 5px solid gray; margin: 0;} 最终元素的总宽度计算公式是这样的：总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距 元素的总高度最终计算公式是这样的：总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距 浏览器的兼容性问题一旦为页面设置了恰当的 DTD，大多数浏览器都会按照上面的图示来呈现内容。然而 IE 5 和 6 的呈现却是不正确的。根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。 虽然有方法解决这个问题。但是目前最好的解决方案是回避这个问题。也就是，不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素和子元素。 IE8 及更早 IE 版本不支持设置填充的宽度和边框的宽度属性。 解决 IE8 及更早版本不兼容问题可以在 HTML 页面声明 &lt;!DOCTYPE html&gt; 即可。 标准盒模型和怪异盒模型的区别标准盒与怪异盒的区别在于他们的总宽度的计算公式不一样。 标准模式下总宽度 = width+margin（左右）+ padding（左右）+ border（左右）；怪异模式下总宽度 = width + margin（左右）（就是说 width 已经包含了 padding 和 border 值）。 标准模式下如果定义的 DOCTYPE 缺失，则在 ie6、ie7、ie8 下汇触发怪异模式。当设置为 box-sizing: content-box 时，将采用标准模式解析计算，也是默认模式；当设置为 box-sizing: border-box 时，将采用怪异模式解析计算。","link":"/2020/03/04/yuque/CSS%20%E7%9B%92%E6%A8%A1%E5%9E%8B/"},{"title":"JS 性能优化之编译原理","text":"JS 是编译型还是解释型语言其实并不固定。首先 JS 需要有引擎才能运行起来，无论是浏览器还是在 Node 中，这是解释型语言的特性。但是在 V8 引擎下，又引入了 TurboFan 编译器，他会在特定的情况下进行优化，将代码编译成执行效率更高的 Machine Code，当然这个编译器并不是 JS 必须需要的，只是为了提高代码执行性能，所以总的来说 JS 更偏向于解释型语言。 在这一过程中，JS 代码首先会解析为抽象语法树（AST），然后会通过解释器或者编译器转化为 Bytecode 或者 Machine CodeV8 转化代码的过程**JS 会首先被解析为 AST，解析的过程其实是略慢的。代码越多，解析的过程也就耗费越长，这也是我们需要压缩代码的原因之一。另外一种减少解析时间的方式是预解析，会作用于未执行的函数。 2016 年手机解析 JS 代码的速度 这里需要注意一点，对于函数来说，应该尽可能避免声明嵌套函数（类也是函数），因为这样会造成函数的重复解析。 1234function test1() { // 会被重复解析 function test2() {}} 然后 Ignition 负责将 AST 转化为 Bytecode，TurboFan 负责编译出优化后的 Machine Code，并且 Machine Code 在执行效率上优于 Bytecode 那么什么情况下代码会编译为 Machine Code？**JS 是一门*动态类型\\*的语言，并且还有一大堆的规则。简单的加法运算代码，内部就需要考虑好几种规则，比如数字相加、字符串相加、对象和字符串相加等等。这样的情况也就势必导致了内部要增加很多判断逻辑，降低运行效率。 12345678function test(x) { return x + x;}test(1);test(2);test(3);test(4); 对于以上代码来说，如果一个函数被多次调用并且参数一直传入 number 类型，那么 V8 就会认为该段代码可以编译为 Machine Code，因为你固定了类型，不需要再执行很多判断逻辑了。 但是如果一旦我们传入的参数类型改变，那么 Machine Code 就会被 DeOptimized 为 Bytecode，这样就有性能上的一个损耗了。所以如果我们希望代码能多的编译为 Machine Code 并且 DeOptimized 的次数减少，就应该尽可能保证传入的类型一致。 那么你可能会有一个疑问，到底优化前后有多少的提升呢，接下来我们就来实践测试一下到底有多少的提升。 1234567891011121314151617181920212223242526const { performance, PerformanceObserver } = require(\"perf_hooks\");function test(x) { return x + x;}// node 10 中才有 PerformanceObserver// 在这之前的 node 版本可以直接使用 performance 中的 APIconst obs = new PerformanceObserver((list, observer) =&gt; { console.log(list.getEntries()); observer.disconnect();});obs.observe({ entryTypes: [\"measure\"], buffered: true });performance.mark(\"start\");let number = 10000000 % // 不优化代码 NeverOptimizeFunction(test);while (number--) { test(1);}performance.mark(\"end\");performance.measure(\"test\", \"start\", \"end\"); 以上代码中使用了 performance API，这个 API 在性能测试上十分好用。不仅可以用来测量代码的执行时间，还能用来测量各种网络连接中的时间消耗等等，并且这个 API 也可以在浏览器中使用。 优化与不优化代码之间的巨大差距 从上图中我们可以发现，优化过的代码执行时间只需要 9ms，但是不优化过的代码执行时间却是前者的二十倍，已经接近 200ms 了。在这个案例中，我相信大家已经看到了 V8 的性能优化到底有多强，只需要我们符合一定的规则书写代码，引擎底层就能帮助我们自动优化代码。 另外，编译器还有个骚操作 Lazy-Compile，当函数没有被执行的时候，会对函数进行一次预解析，直到代码被执行以后才会被解析编译。对于上述代码来说，test 函数需要被预解析一次，然后在调用的时候再被解析编译。但是对于这种函数马上就被调用的情况来说，预解析这个过程其实是多余的，那么有什么办法能够让代码不被预解析呢？ 其实很简单，我们只需要给函数套上括号就可以了 123(function test(obj) { return x + x;}); 但是不可能我们为了性能优化，给所有的函数都去套上括号，并且也不是所有函数都需要这样做。我们可以通过 optimize-js 实现这个功能，这个库会分析一些函数的使用情况，然后给需要的函数添加括号，当然这个库很久没人维护了，如果需要使用的话，还是需要测试过相关内容的。 所以，这应该也是使用 TypeScript 能够带来的好处之一。","link":"/2020/03/30/yuque/JS%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"title":"JSX.Element VS ReactNode VS ReactElement","text":"摘自：https://stackoverflow.com/questions/58123398/when-to-use-jsx-element-vs-reactnode-vs-reactelement 查看 TypeScript 的类型定义，你会发现： ReactElement 是具有类型和属性的对象： 12345678910interface ReactElement&lt; P = any, T extends string | JSXElementConstructor&lt;any&gt; = | string | JSXElementConstructor&lt;any&gt;&gt; { type: T; props: P; key: Key | null;} ReactNode 是 ReactElement，ReactFragment，string，number 或者 ReactNodeArr，或者为 undefined，null 或 boolean： 1234567891011type ReactText = string | number;type ReactChild = ReactElement | ReactText;interface ReactNodeArray extends Array&lt;ReactNode&gt; {}type ReactFragment = {} | ReactNodeArray;type ReactNode = | ReactChild | ReactFragment | ReactPortal | boolean | null | undefined; JSX.Element 是一个 ReactElement，props 的泛型类型是任意类型。它存在，因为各种库都可以以自己的方式实现 JSX，因此 JSX 是一个全局命名空间，然后由该库设置，React 对其进行如下设置： 12345declare global { namespace JSX { interface Element extends React.ReactElement&lt;any, any&gt; {} }} 举个 🌰12345&lt;p&gt; // &lt;- ReactElement = JSX.Element &lt;Custom&gt; // &lt;- ReactElement = JSX.Element {true &amp;&amp; \"test\"} // &lt;- ReactNode &lt;/Custom&gt; &lt;/p&gt;","link":"/2020/03/05/yuque/JSX.Element%20VS%20ReactNode%20VS%20ReactElement/"},{"title":"JavaScript 中的 this 指向","text":"原文地址：https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20%26%20object%20prototypes/ch2.md#%E4%BB%85%E4%BB%85%E6%98%AF%E8%A7%84%E5%88%99 首先关于 this 指向的问题，其实可以简单的理解为在哪里调用函数，其 this 指向就指向谁(箭头函数除外)。所以我们必须得理解调用点(即函数在代码中被调用的位置而不是被声明的位置)。 在 JavaScript 中，在你编写完代码，当引擎执行之前会进行预编译(也可以称为解析)，然后会形成对应的作用域。 在你声明函数的时候就确定作用域的称之为词法作用域，即为编译器对词法进行分析然后形成的作用域。这适用于大部分情况，然后 this 的表现形式与词法作用域不同，因为其是在被调用的时候确定其值，所以可以将其形成的作用域称为动态作用域。关于作用域可见：https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20%26%20closures/ch1.md 接下来对 this 指向进行分类讨论： this 指向默认绑定我们要考察的第一种规则源于函数调用的最常见的情况：独立函数调用。可以认为这种 this 规则是在没有其他规则适用时的默认规则。 1234567function foo() { console.log(this.a);}var a = 2;foo(); // 2 当 foo() 被调用时， 此时方法调用 this 实施了默认绑定，所以 this 指向全局对象(strict 模式下指向 undefined)。 在该代码片段中，foo() 是被一个直白且毫无修饰的函数引用调用的，没有其他的我们将要展示的规则适用于这里。 简单来说，就是此书的 foo() 是直接执行，所以其 this 指向是默认指向 window 对象的。 一个微妙但是重要的细节是：即便所有的 this 绑定规则都是完全基于调用点的，但如果 foo() 的 内容 没有在 strict mode 下执行，对于 默认绑定 来说全局对象是 唯一 合法的；foo() 的调用点的 strict mode 状态与此无关。 1234567891011function foo() { console.log(this.a);}var a = 2;(function () { \"use strict\"; foo(); // 2})(); 注意： 在你的代码中故意混用 strict mode 和非 strict mode 通常是让人皱眉头的。你的程序整体可能应当不是 Strict 就是 非 Strict。然而，有时你可能会引用与你的 Strict 模式不同的第三方包，所以对这些微妙的兼容性细节要多加小心。 隐含绑定另一种要考虑的规则是：调用点是否有一个环境对象（context object），也称为拥有者（owning）或容器（containing）对象，虽然这些名词可能有些误导人。 12345678910function foo() { console.log(this.a);}var obj = { a: 2, foo: foo,};obj.foo(); // 2 首先，注意 foo() 被声明然后作为引用属性添加到 obj 上的方式。无论 foo() 是否一开始就在 obj 上被声明，还是后来作为引用添加（如上面代码所示），这个 函数 都不被 obj 所真正“拥有”或“包含”。 然而，调用点 使用 obj 环境来 引用 函数，所以你 可以说 obj 对象在函数被调用的时间点上“拥有”或“包含”这个 函数引用。 不论你怎样称呼这个模式，在 foo() 被调用的位置上，它被冠以一个指向 obj 的对象引用。当一个方法引用存在一个环境对象时，隐含绑定 规则会说：是这个对象应当被用于这个函数调用的 this 绑定。 因为 obj 是 foo() 调用的 this，所以 this.a 就是 obj.a 的同义词。只有对象属性引用链的最后一层是影响调用点的。比如： 123456789101112131415function foo() { console.log(this.a);}var obj2 = { a: 42, foo: foo,};var obj1 = { a: 2, obj2: obj2,};obj1.obj2.foo(); // 42 隐含丢失this 绑定最常让人沮丧的事情之一，就是当一个 隐含绑定 丢失了它的绑定，这通常意味着它会退回到 _默认绑定_， 根据 strict mode 的状态，其结果不是全局对象就是 undefined。 1234567891011121314function foo() { console.log(this.a);}var obj = { a: 2, foo: foo,};var bar = obj.foo; // 函数引用！var a = \"oops, global\"; // `a` 也是一个全局对象的属性bar(); // \"oops, global\" 尽管 bar 似乎是 obj.foo 的引用，但实际上它只是另一个 foo 本身的引用而已。另外，起作用的调用点是 bar()，一个直白，毫无修饰的调用，因此 默认绑定 适用于这里。 这种情况发生的更加微妙，更常见，而且更意外的方式，是当我们考虑传递一个回调函数时： 123456789101112131415161718function foo() { console.log(this.a);}function doFoo(fn) { // `fn` 只不过 `foo` 的另一个引用 fn(); // &lt;-- 调用点!}var obj = { a: 2, foo: foo,};var a = \"oops, global\"; // `a` 也是一个全局对象的属性doFoo(obj.foo); // \"oops, global\" 参数传递仅仅是一种隐含的赋值，而且因为我们在传递一个函数，它是一个隐含的引用赋值，所以最终结果和我们前一个代码段一样。 那么如果接收你所传递回调的函数不是你的，而是语言内建的呢？没有区别，同样的结果。 123456789101112function foo() { console.log(this.a);}var obj = { a: 2, foo: foo,};var a = \"oops, global\"; // `a` 也是一个全局对象的属性setTimeout(obj.foo, 100); // \"oops, global\" 正如我们刚刚看到的，我们的回调函数丢掉他们的 this 绑定是十分常见的事情。但是 this 使我们吃惊的另一种方式是，接收我们回调的函数故意改变调用的 this。那些很流行的 JavaScript 库中的事件处理器就十分喜欢强制你的回调的 this 指向触发事件的 DOM 元素。虽然有时这很有用，但其他时候这简直能气死人。不幸的是，这些工具很少给你选择。 不管哪一种意外改变 this 的方式，你都不能真正地控制你的回调函数引用将如何被执行，所以你（还）没有办法控制调用点给你一个故意的绑定。我们很快就会看到一个方法，通过 固定 this 来解决这个问题。 明确绑定即使用 call 或者 apply 显示绑定 this 的指向，而通过 bind 来绑定的称之为硬绑定，call、apply、bind 这种明确的给 this 进行的绑定我们都称之为明确绑定。 123456789function logThis(...args) { console.log(\"this\", this); console.log(\"args\", args);}logThis.call({ a: 1 }, 1, 2, 3);logThis.apply({ a: 2 }, [1, 2, 3]);const bindLogThis = logThis.bind({ a: 3 }, 1, 2, 3);bindLogThis(4, 5, 6); 注意： 在 ES6 中，bind(..) 生成的硬绑定函数有一个名为 .name 的属性，它源自于原始的 _目标函数（target function）_。举例来说：bar = foo.bind(..) 应该会有一个 bar.name 属性，它的值为 &quot;bound foo&quot;，这个值应当会显示在调用栈轨迹的函数调用名称中。 API 调用的“环境”确实，许多库中的函数，和许多在 JavaScript 语言以及宿主环境中的内建函数，都提供一个可选参数，通常称为“环境（context）”，这种设计作为一种替代方案来确保你的回调函数使用特定的 this 而不必非得使用 bind(..)。 12345678910function foo(el) { console.log(el, this.id);}var obj = { id: \"awesome\",};// 使用 `obj` 作为 `this` 来调用 `foo(..)`[1, 2, 3].forEach(foo, obj); // 1 awesome 2 awesome 3 awesome 从内部来说，几乎可以确定这种类型的函数是通过 call(..) 或 apply(..) 来使用 明确绑定 以节省你的麻烦。 new 绑定这个很简单，就是通过实例化一个 constructor，那么该构造函数的 this 指向该实例化的对象。 当在函数前面被加入 new 调用时，也就是构造器调用时，下面这些事情会自动完成： 一个全新的对象会凭空创建（就是被构建） 这个新构建的对象会被接入原形链（[[Prototype]]-linked） 这个新构建的对象被设置为函数调用的 this 绑定 除非函数返回一个它自己的其他 对象，否则这个被 new 调用的函数将 自动 返回这个新构建的对象。 123456function foo(a) { this.a = a;}var bar = new foo(2);console.log(bar.a); // 2 优先级测试很显然，默认绑定 在四种规则中优先权最低的。所以我们先把它放在一边。 隐含绑定 和 明确绑定对比： 12345678910111213141516171819function foo() { console.log(this.a);}var obj1 = { a: 2, foo: foo,};var obj2 = { a: 3, foo: foo,};obj1.foo(); // 2obj2.foo(); // 3obj1.foo.call(obj2); // 3obj2.foo.call(obj1); // 2 所以, 明确绑定 的优先权要高于 隐含绑定_，这意味着你应当在考察 _隐含绑定 之前 首先 考察 明确绑定 是否适用。 现在，我们只需要搞清楚 new 绑定 的优先级位于何处。 12345678910111213141516171819function foo(something) { this.a = something;}var obj1 = { foo: foo,};var obj2 = {};obj1.foo(2);console.log(obj1.a); // 2obj1.foo.call(obj2, 3);console.log(obj2.a); // 3var bar = new obj1.foo(4);console.log(obj1.a); // 2console.log(bar.a); // 4 好了，new 绑定 的优先级要高于 隐含绑定_。那么你觉得 _new 绑定 的优先级较之于 明确绑定 是高还是低呢？ 注意： new 和 call/apply 不能同时使用，所以 new foo.call(obj1) 是不允许的，也就是不能直接对比测试 new 绑定 和 明确绑定_。但是我们依然可以使用 _硬绑定 来测试这两个规则的优先级。 12345678910111213function foo(something) { this.a = something;}var obj1 = {};var bar = foo.bind(obj1);bar(2);console.log(obj1.a); // 2var baz = new bar(3);console.log(obj1.a); // 2console.log(baz.a); // 3 bar 是硬绑定到 obj1 的，但是 new bar(3) 并 没有 像我们期待的那样将 obj1.a 变为 3。反而，硬绑定_（到 obj1）的 bar(..) 调用 _可以 被 new 所覆盖。因为 new 被实施，我们得到一个名为 baz 的新创建的对象，而且我们确实看到 baz.a 的值为 3。 结论现在，我们可以按照优先顺序来总结一下从函数调用的调用点来判定 this 的规则了。按照这个顺序来问问题，然后在第一个规则适用的地方停下。 函数是通过 new 被调用的吗（new 绑定）？如果是，this 就是新构建的对象。var bar = new foo() 函数是通过 call 或 apply 被调用（明确绑定），甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。var bar = foo.call( obj2 ) 函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个环境对象。var bar = obj1.foo() 否则，使用默认的 this（默认绑定）。如果在 strict mode 下，就是 undefined，否则是 global 对象。var bar = foo() 注意：箭头函数的 this 指向其父级作用域的 this 的指向，箭头函数使用词法作用域来决定 this 绑定，这意味着它们采用封闭他们的函数调用作为 this 绑定（无论它是什么）。它们实质上是 ES6 之前的 self = this 代码的语法替代品。","link":"/2020/07/15/yuque/JavaScript%20%E4%B8%AD%E7%9A%84%20this%20%E6%8C%87%E5%90%91/"},{"title":"JavaScript 面向对象之继承","text":"面向对象编程就是将需求抽象成一个对象，然后针对这个对象分析其特征(属性)和动作(方法)。这边对象我们称之为“类”。面向对象的特征就是：继承、封装、多态和抽象。在 JavaScript 中，对于这种解释性的弱类型语言没有经典强类型语言中那种通过 class 等关键字实现的类的封装方式。JavaScript 中都是通过一些特性模仿实现的，但这也带来了极高的灵活性，让我们编写的代码更自由。需要注意的是，JavaScript 中并没有真正的类，es6 中的 class 也是通过原型和与原型链的方式去模拟类而已。在读 JavaScript 设计模式的时候，发现 JavaScript 中实现继承有好几种方式，由于概念个人觉得有点多且绕，所以这里就统一做下学习总结： 1. 类式继承(父类实例化的对象直接赋值给子类的 prototype)：123456789101112131415161718// 父类function Parent() { this.parentValue = true;}// 为父类添加共有方法Parent.prototype.getParentValue = function () { return this.parentValue;};// 子类function Child() { this.childValue = false;}// 继承父类Child.prototype = new Parent();// 为子类添加共有方法Child.prototype.getChildValue = function () { return this.childValue;}; 缺陷：1. 由于子类通过其原型 prototype 对父类实例化，继承了父类。所以说父类中的共有属性要是引用类型，就会在子类中被所有实例共用，因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类。2. 由于子类实现的继承是通过其原型 prototype 对父类实例化实现的，因此在创建父类的时候，是无法向父类传递参数的，因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化。 2. 构造函数继承(子类构造函数 call 父类构造函数)：12345678910111213// 父类function Parent(name) { this.name = name; this.books = [\"html\", \"css\", \"JavaScript\"];}Parent.prototype.getName = function () { return this.name;};// 子类function Child(name, time) { Parent.call(this, name); this.time = time;} 这种类型的继承没有涉及原型 prototype，所以父类的原型方法自然不会被子类继承，而如果要想被子类继承就必须要放在构造函数中，这样创建出来的每个实例都会单独拥有一份而不能共用，这样就违背了代码复用的原则。 3. 组合继承(类式继承 + 构造函数继承)：以上两个继承方式结合，所以在此不再赘述。在子类构造函数中执行父类构造函数，在子类原型上实例化父类就是组合模式，这样就融合了类式继承和构造函数继承的优点，并且过滤掉其缺点。 4. 原型式继承(与类式继承相似, 同 object.create())12345678function inheritObject(o) { // 声明一个过渡函数对象 function F() {} // 过渡对象的原型继承父对象 F.prototype = o; // 返回过渡对象的一个实例，该实例的原型继承了父对象 return new F();} 5. 寄生式继承(原型式继承增强，原型式继承二次封装)12345678910function createBook(obj) { // 通过原型继承方式创建新对象 const o = new inheritObject(obj); // 扩展新对象 o.getName = function () { return this.name; }; // 返回拓展后的新对象 return o;} 6. 寄生组合式继承(与寄生式继承相似(寄生式继承处理的是对象，此处处理的是类的原型) + 构造函数继承)寄生式继承有些特殊，这里它处理的不是对象，而是类的原型。 12345678function inheritPrototype(Child, Parent) { // 复制一份父类的原型副本保存在变量中 const p = inheritObject(Parent.prototype); // 修正因为重写子类原型导致子类的 constructor 属性被修改 p.constructor = Child; // 设置子类的原型 Child.prototype = p;}","link":"/2020/02/01/yuque/JavaScript%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF/"},{"title":"JavaScript","text":"","link":"/2020/02/01/yuque/JavaScript/"},{"title":"Lisp","text":"","link":"/2020/02/23/yuque/Lisp/"},{"title":"MySQL","text":"","link":"/2020/07/04/yuque/MySQL/"},{"title":"Node.js 中 child_process 实现执行系统命令-exec 和 spawn","text":"脚手架地址：https://github.com/Spencer17x/template-create-cli 在写这个脚手架的时候遇到一个需求需要通过 yarn/npm i 来自动安装依赖和 rui-app update 来更新脚手架。 经过一番 Google 查询、发现通过 child_process 的模块中的 exec 和 spawn 即可实现。 参照 https://juejin.im/post/5e746444518825494e27a383#heading-8 的 install 方法即可实现。 一开始我使用的 exec 来实现、参照了 @tarojs/cli 的 update.ts 文件也是使用 exec 来实现的。地址：https://github.com/NervJS/taro/blob/next/packages/taro-cli/src/presets/commands/update.ts。如下所示 @tarojs/cli ：但是我在我的脚手架项目里尝试 exec 实现时，发现需求是实现了，但是没有具体的进度，你感觉不到是否正在安装。如下对比：(1 是 exec，2 是 spawn))可以明显看出 spawn 方式更有感知、且 install 过程中信息更详细。 于是，我改用 spawn 方式来实现 install 和 update 方式。然后提取公有部分、对该方法进行了一个封装： 12345678910111213141516171819202122232425262728293031323334import { spawn } from \"child_process\";import path from \"path\";interface InstallOptions { pkgManager?: \"yarn\" | \"npm\"; projectName?: string; args?: string[];}/** * 执行命令 * @param installOptions */const install = (installOptions: InstallOptions): Promise&lt;void&gt; =&gt; { return new Promise((resolve, reject) =&gt; { const { pkgManager = \"yarn\", args = [], projectName } = installOptions; const child = spawn(pkgManager, args, { cwd: projectName ? path.join(process.cwd(), projectName) : \"\", stdio: [\"pipe\", process.stdout, process.stderr], }); child.once(\"close\", (code) =&gt; { if (code !== 0) { reject({ pkgManager: `${pkgManager} ${args.join(\" \")}`, }); return; } resolve(); }); child.once(\"error\", reject); });};export default install; 具体可见 https://github.com/Spencer17x/template-create-cli 查看完整代码。 然后总结下 spawn 和 exec 的区别吧： 首先就是他们的用法：exec 首个参数直接输入命令，第二个传入 options，具体可见他们的 api 文档。然而 spawn 第一个参数是命令，第二个是字符串参数列表。 举例区分： 1234567891011// spawnconst ls = spawn('ls', ['-lh', '/usr']);// execexec('cat *.js 文件 | wc -l', (error, stdout, stderr) =&gt; { if (error) { console.error(`执行的错误: ${error}`); return; } console.log(`stdout: ${stdout}`); console.error(`stderr: ${stderr}`);}); 其次就是 exec 是基于 spawn，说明 spawn 更原生，exec 是基于其进行的封装。","link":"/2020/07/25/yuque/Node.js%20%E4%B8%AD%20child_process%20%E5%AE%9E%E7%8E%B0%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4-exec%20%E5%92%8C%20spawn/"},{"title":"React","text":"","link":"/2019/12/27/yuque/React/"},{"title":"Stale Closure","text":"tags: [未完成]","link":"/2019/12/01/yuque/Stale%20Closure/"},{"title":"V8下的垃圾回收机制","text":"V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存(堆)分为新生代和老生代两部分。 新生代算法新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。 在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。 老生代算法老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。 先来说下什么情况下对象会出现在老生代空间中： 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。 To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。 老生代中的空间有如下几个空间： 123456789101112131415enum AllocationSpace { // TODO(v8:7464): Actually map this space's memory as read-only. RO_SPACE, // 不变的对象空间 NEW_SPACE, // 新生代用于 GC 复制算法的空间 OLD_SPACE, // 老生代常驻对象空间 CODE_SPACE, // 老生代代码对象空间 MAP_SPACE, // 老生代 map 对象 LO_SPACE, // 老生代大空间对象 NEW_LO_SPACE, // 新生代大空间对象 FIRST_SPACE = RO_SPACE, LAST_SPACE = NEW_LO_SPACE, FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE, LAST_GROWABLE_PAGED_SPACE = MAP_SPACE}; 在老生代中，以下情况会先启动标记清除算法： 某一个空间没有分块的时候 空间中的对象超过一定限制 空间不能保证新生代中的对象移动到老生代中 在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型堆内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 该博客 详细阅读。 清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。","link":"/2020/03/31/yuque/V8%E4%B8%8B%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"title":"antd引入后css无效","text":"在写一个基于 scratch 开发的项目的时候，由于该项目 webpack 是作者自己配的。所以按照 antd 的文档引入 antd，并进行对应配置发现不起作用。 配置如下： 使用 babel-plugin-import（推荐）。 12345678910// .babelrc or babel-loader option{ \"plugins\": [ [\"import\", { \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": \"css\" // `style: true` 会加载 less 文件 }] ]} 然后只需从 antd 引入模块即可，无需单独引入样式。等同于下面手动引入的方式。 12// babel-plugin-import 会帮助你加载 JS 和 CSSimport { DatePicker } from \"antd\"; 后排查问题在于这: 所以你新建 .babelrc 文件配置是无效的哦，但是我又不敢改这个，原项目太复杂，我就只能寻找其他方法。 首先就是如图中把配置 antd 的配置如图写，而不是写在 .babelrc 文件中。 然后搜索了相关 issue 和文章，看到了这个 https://blog.csdn.net/zwkkkk1/article/details/88823366。 [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;style&quot;: true }]：引入的是 less 文件，需要在 webpack.config.js 额外配置 less-loader 等，且不能在 module.rules 中把 node_modules/antd 给 exclude 了。 所以进行如下操作: 一开始，按文章配置还是会报错，然后搜到这个 issue: https://github.com/ant-design/ant-design/issues/7927 issue 里有人提到，less@2.x 是 OK 的。 less@3.x，需要开启 配置项 javascriptEnabled: true 1{ loader: 'less-loader', options: { javascriptEnabled: true } } 最终，完美解决。 还有个小插曲：webpack 配置 devServer 的 proxy 的时候，发现代理过去都是报 500，于是操作如下解决： 问题出在少了个 changeOrigin: true，添加完后完美解决。","link":"/2020/07/04/yuque/antd%E5%BC%95%E5%85%A5%E5%90%8Ecss%E6%97%A0%E6%95%88/"},{"title":"axios不会对url中的功能性字符进行编码","text":"在请求中如果 url 包括特殊字符的话，可能会导致接口接收参数失败，所以前端一般会对特殊字符进行 encode，方法有两种 encodeURI() 对整个 url 进行编码，会避开 url 中的功能性字符，例如，&amp; ? [ ] 编码前：http://10.10.67.67:8080/api/chain/basic/users?params=+[ 编码后：http://10.10.67.67:8080/api/chain/basic/users?params=%2B[ encodeURIComponent() 对某个参数进行编码，会编码所有特殊字符 编码前：http://10.10.67.67:8080/api/chain/basic/users?params=+[ 编码后：http://10.10.67.67:8080/api/chain/basic/users?params=%2b%5B 在 axios 中就会对 get 请求的整个 url 进行 encodeURI，导致有些 get 方法不能传[]，所以在请求拦截器中可以对 get 方法单独处理，避开 axios 的 encodeURI 123456789101112131415myAxios.interceptors.request.use((config) =&gt; { let url = config.url; // get参数编码 if (config.method === \"get\" &amp;&amp; config.params) { url += \"?\"; let keys = Object.keys(config.params); for (let key of keys) { url += `${key}=${encodeURIComponent(config.params[key])}&amp;`; } url = url.substring(0, url.length - 1); config.params = {}; } config.url = url; return config;}); 参考： https://blog.csdn.net/weixin_33912246/article/details/88536514 https://github.com/axios/axios/blob/master/lib/helpers/buildURL.js","link":"/2020/07/04/yuque/axios%E4%B8%8D%E4%BC%9A%E5%AF%B9url%E4%B8%AD%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7%E5%AD%97%E7%AC%A6%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81/"},{"title":"element ui - NavMenu 组件二次封装","text":"在对 NavMenu 组件进行二次封装的时候，一开始采用如下方式： 第 1 种方案地址：https://codesandbox.io/s/serene-darkness-70kq1?file=/src/App.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// App.vue&lt;template&gt; &lt;div id=\"app\"&gt; &lt;el-menu&gt; &lt;RecursiveSubMenu v-for=\"menuItem in menuList\" :key=\"menuItem.index\" :menuItem=\"menuItem\"/&gt; &lt;/el-menu&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import RecursiveSubMenu from \"./components/RecursiveSubMenu.vue\";export default { name: \"App\", components: { RecursiveSubMenu }, data() { return { menuList: [ { content: \"tab 1\", index: \"1\", children: [ { content: \"tab 1-1\", index: \"1-1\" }, { content: \"tab 1-2\", index: \"1-2\" } ] }, { content: \"tab 2\", index: \"2\", children: [ { content: \"tab 2-1\", index: \"2-1\" }, { content: \"tab 2-2\", index: \"2-2\" } ] } ] }; }};&lt;/script&gt; 12345678910111213141516171819202122232425262728// ./components/RecursiveSubMenu.vue&lt;template&gt; &lt;div&gt; &lt;template v-if=\"menuItem.children &amp;&amp; menuItem.children.length\"&gt; &lt;el-submenu :index=\"menuItem.index\" :key=\"menuItem.index\"&gt; &lt;template slot=\"title\"&gt;{{menuItem.content}}&lt;/template&gt; &lt;RecursiveSubMenu v-for=\"item in menuItem.children\" :menuItem=\"item\" :key=\"item.index\"/&gt; &lt;/el-submenu&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;el-menu-item :index=\"menuItem.index\" :key=\"menuItem.index\"&gt;{{menuItem.content}}&lt;/el-menu-item&gt; &lt;/template&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: \"RecursiveSubMenu\", props: { menuItem: { type: Object, default() { return {}; } } }};&lt;/script&gt; 这存在一个明显的问题，就是递归组件里多了个 div 标签，破坏了原有组件的结构，所以可能样式会错乱、出现问题，解决方案很简单就是通过修改样式来修复问题，可以通过样式穿透或者去除 scope 来修改样式。 第 2 种方案：地址：https://codesandbox.io/s/determined-allen-9e5gx?file=/src/App.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// App.vue&lt;template&gt; &lt;div id=\"app\"&gt; &lt;el-menu&gt; &lt;template v-for=\"item in menuList\"&gt; &lt;RecursiveSubMenu v-if=\"item.children\" :data=\"item\" :key=\"item.index\" /&gt; &lt;el-menu-item v-else :index=\"item.index\" :key=\"item.index\" &gt;{{ item.content }}&lt;/el-menu-item&gt; &lt;/template&gt; &lt;/el-menu&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import RecursiveSubMenu from \"./components/RecursiveSubMenu.vue\";export default { name: \"App\", components: { RecursiveSubMenu }, data() { return { menuList: [ { content: \"tab 1\", index: \"1\", children: [ { content: \"tab 1-1\", index: \"1-1\" }, { content: \"tab 1-2\", index: \"1-2\" } ] }, { content: \"tab 2\", index: \"2\", children: [ { content: \"tab 2-1\", index: \"2-1\" }, { content: \"tab 2-2\", index: \"2-2\" } ] } ] }; }};&lt;/script&gt; 123456789101112131415161718192021222324// ./components/RecursiveSubMenu.vue&lt;template&gt; &lt;el-submenu :index=\"data.index\"&gt; &lt;template slot=\"title\"&gt;{{ data.content }}&lt;/template&gt; &lt;template v-for=\"item in data.children\"&gt; &lt;RecursiveSubMenu v-if=\"item.children\" :data=\"item\" :key=\"item.index\"/&gt; &lt;el-menu-item v-else :index=\"item.index\" :key=\"item.index\"&gt;{{ item.content }}&lt;/el-menu-item&gt; &lt;/template&gt; &lt;/el-submenu&gt;&lt;/template&gt;&lt;script&gt;export default { name: \"RecursiveSubMenu\", props: { data: { type: Object, default: () =&gt; { return {}; } } }};&lt;/script&gt; 第 2 种可见不会影响到原有的元素结构，然后在某些情况下第 2 种方案会使得控制台报错递归爆栈，然而并不会影响功能，具体可见： https://github.com/ElemeFE/element/pull/17133 https://github.com/ElemeFE/element/issues/17391 最终我是通过使用第 1 种方案，造成方案 2 递归爆栈的原因主要是由于源码中 $parent 取值错误，如下图解释：综上，两种方案都可，因为 issue 中方案 2 也被别人提的 pr 修复了，只不过一直没 merge，具体可自行尝试修改。","link":"/2020/07/25/yuque/element%20ui%20-%20NavMenu%20%E7%BB%84%E4%BB%B6%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85/"},{"title":"generator函数yield暂存问题","text":"在阅读 https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/async %26 performance/ch4.md#穿插 的时候，对于该题输出理解不了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445var a = 1;var b = 2;function* foo() { a++; yield; b = b * a; a = (yield b) + 3;}function* bar() { b--; yield; a = (yield 8) + b; b = a * (yield 2);}function step(gen) { var it = gen(); var last; return function () { // 不论`yield`出什么，只管在下一次时直接把它塞回去！ last = it.next(last).value; };}// 确保重置了`a`和`b`a = 1;b = 2;var s1 = step(foo);var s2 = step(bar);s2(); // b--;s2(); // 让出 8s1(); // a++;s2(); // a = 8 + b;// 让出 2s1(); // b = b * a;// 让出 bs1(); // a = b + 3;s2(); // b = a * 2;console.log(a, b); // 12 18 理解不了的问题在于 b 的值为何为 18，一开始理解是最后一个 s1 执行完之后，a 已经为 12 了，所以认为最后一个 s2 执行的时候是为 b = 12 * 2 。后在群里与大佬讨论，推测 yield 存在暂存，使得最后执行 b = a * (yield 2) 的时候此时的 a 取之前暂存的值 9，所以即为 b = 9 * 2 。 为了验证 yield 可能存在暂存，所以编写如下代码测试： 12345678910111213var count = 0;function* testGen() { count = 2; yield count * (yield 2);}const gen = testGen();gen.next(); // {value: 2, done: false}count += 100; // 102gen.next(2); // {value: 4, done: false}count; // 102 经测试，执行完 gen 的第一个 next 迭代器之后，此时的 *testGen 函数中 count 被暂存下来了，无论外部如何修改 count 的值，都不会影响暂存下来的 *testGen 函数中 count 值。 后来大佬又推测内部的值的是提前算好的(我不太认同这个，因为到 yield 的时候已经被暂停了，无法执行到赋值的操作的)，个人测试代码如下： 123456789var count = 0;function* f() { console.log(yield count, 1);}const gen = f();gen.next(); // {value: 0, done: false} 个人认为如果说内部是提前计算好的话，那么 log 1 应该会被打印出来，然而并没有，所以猜测不是提前计算好的。当时分析这种情况是因为大佬认为暂存的话得找个新的内存地址，认为语言作者不会那么浪费内存。 后搜索关于 yield 暂存 的问题搜索到了 python 相关文章： https://blog.csdn.net/qq_36852780/article/details/104506475 https://www.codetd.com/article/9835048 里面提到了 yield 的暂存功能。所以推测 JavaScript 中关于 generator 函数相关的是借鉴于 python 的。所以认为理解为 yield 暂存更为靠谱。所以具体深入理解的话应该还得去分析 v8 源码吧？","link":"/2020/10/09/yuque/generator%E5%87%BD%E6%95%B0yield%E6%9A%82%E5%AD%98%E9%97%AE%E9%A2%98/"},{"title":"ios input框失焦导致按钮点击无效","text":"问题：由于项目的用户基本集中于微信，所以该项目运行在微信浏览器的环境中。 当用户聚焦于 input 输入内容后，输入结束失焦后，用户点击其他按钮后发现无任何反应。 通过测试后发现安卓手机下正常，ios 下会产生该问题。 于是推测为 ios 的 input 失效后，input 光标错位，导致点击的位置不在按钮上。 解决方案:通过给 input 设置 blur(失焦)事件，失焦后页面滚动到顶部即可解决： 1window.scroll(0, 0); 缺陷：如果有多个 input 就得为每个 input 设置 scroll 事件，降低了性能，也给绑定了多个事件。 后续如果发现有更好的替代方案再进行补充。","link":"/2020/07/04/yuque/ios%20input%E6%A1%86%E5%A4%B1%E7%84%A6%E5%AF%BC%E8%87%B4%E6%8C%89%E9%92%AE%E7%82%B9%E5%87%BB%E6%97%A0%E6%95%88/"},{"title":"mongoose查询不到数据表中的数据的问题","text":"在做 koa+mongdb 的项目时候，定义了一个 UserSchema 如何所示： 12345678import { Schema, model } from \"mongoose\";const UserSchema = new Schema({ username: { type: String }, password: { type: String },});export default model(\"user\", UserSchema); 然后查询如下所示： 1234567891011121314import { Context } from \"koa\";import { UserModel } from \"../models\";class UserCtrl { /** * 查询所有用户 */ async findAllUsers(ctx: Context) { const users = await UserModel.find({}); ctx.body = users; }}export default new UserCtrl(); 结果发现返回为空数组，结果也没任何报错与提示，但是我已经向数据库中的 user 表插入了一条数据。 后经搜索得知：如果没有第三个参数的话，mongoose 在编译模式生成模型的时候会自动改模型的名字加上’s’作为数据库中对应的表名，第三个参数是指数据库中的表名，所以第二种方式，我们不需要改表名，只需要指定第三个参数就行了。 如下修改即可： 12345678import { Schema, model } from \"mongoose\";const UserSchema = new Schema({ username: { type: String }, password: { type: String },});export default model(\"user\", UserSchema, \"user\"); 参考文章：https://www.cnblogs.com/toward-the-sun/p/6610396.html","link":"/2020/07/01/yuque/mongoose%E6%9F%A5%E8%AF%A2%E4%B8%8D%E5%88%B0%E6%95%B0%E6%8D%AE%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"mysql安装和密码问题","text":"记录自己第一次在 mac 安装和登录 mysql 遇到的问题。 在安装 mysql 之后登录 mysql 提示如下： 1ERROR 1045 (28000) Access denied for user (using password YES)。 搜索了绝大部分文章尝试了都无效。尝试过绕过密码登录，发现还是一直提示该错误。 后来想了下可能是 mysql 重装的时候没有卸载干净的问题。 于是进行了如下操作彻底清除 mysql： 1234$ brew remove mysql$ brew cleanup$ launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist$ rm -Rf ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist 然后重装后登录，OK。 记录一下安装 mysql 版本的问题：mysql5 版本安装的时候会默认给你生成一串初始的密码，可能不太会有人注意，所以安装的过程中手速得放慢，不小心手速快了也可以通过搜索文章来修改初始密码。 mysql8 版本安装的时候会让你自己输入初始密码，安装之后你想要修改密码的话也可以通过搜索相关文章进行修改，但是 mysql8 版本的密码机制不同于老版本，具体方法可以自行 Google。","link":"/2020/07/04/yuque/mysql%E5%AE%89%E8%A3%85%E5%92%8C%E5%AF%86%E7%A0%81%E9%97%AE%E9%A2%98/"},{"title":"on事件覆盖的问题","text":"记一次犯傻的问题。代码 codesandbox 地址：https://codesandbox.io/s/tender-knuth-g7po5在使用 hooks 的时候发现如下代码片段在浏览器窗口缩放时只有最后一个 Child 组件会触发 rerender。 123456789101112131415161718192021222324252627282930313233import React, { useState, useEffect } from \"react\";import ReactDOM from \"react-dom\";import \"./styles.css\";function useScreen(initialValue) { const [w, setW] = useState(initialValue); useEffect(() =&gt; { const handleResize = () =&gt; setW(document.body.clientWidth); // 错误方式 window.onresize = handleResize; // 正确打开方式 // window.addEventListener('resize', handleResize); }, []); return w;}function Child() { const w = useScreen(0); return &lt;div&gt;{w}&lt;/div&gt;;}function App() { return ( &lt;div className=\"App\"&gt; &lt;h1&gt;Hello CodeSandbox&lt;/h1&gt; &lt;h2&gt;Start editing to see some magic happen!&lt;/h2&gt; &lt;Child /&gt; &lt;Child /&gt; &lt;/div&gt; );}const rootElement = document.getElementById(\"root\");ReactDOM.render(&lt;App /&gt;, rootElement); 刚开始以为是 hooks 的问题，于是将其去掉 hooks 改成 class 组件发现还是不行。后通过询问方方老师，才发现自己犯傻了。第一次赋值 window.onresize，第二次又赋值 window.onresize，最终后一个会覆盖前一个 window.onresize，所以导致了只有最后一个 Child 才会 rerender。通过将 window.onresize 改为 window.addEventListener 的方式即可完美解决该问题。","link":"/2020/07/01/yuque/on%E4%BA%8B%E4%BB%B6%E8%A6%86%E7%9B%96%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"requre.context单测报错","text":"写项目的时候有个 js 文件的代码如下： 12345// 导入所有iconconst importAll = (requireContext) =&gt; requireContext.keys().forEach(requireContext);importAll(require.context(\"./svgs/\", true, /\\.svg$/)); 改代码此处不做解释，感兴趣可参考：https://webpack.docschina.org/guides/dependency-management/#require-context然后跑单测的时候 Icon 组件的单测会报错，因为 Icon 组件有涉及到该代码，通过该代码引入 icon 的 svg。相关 issue：https://github.com/storybookjs/storybook/issues/2487报错如下： 解决方案： 123456789// 导入所有iconconst importAll = (requireContext) =&gt; requireContext.keys().forEach(requireContext);try { importAll(require.context(\"./svgs/\", true, /\\.svg$/));} catch (error) { // console.log(error);}","link":"/2020/07/01/yuque/requre.context%E5%8D%95%E6%B5%8B%E6%8A%A5%E9%94%99/"},{"title":"swiper loop：true引发绑定dom的click事件无效及解决方案","text":"文章摘自：https://juejin.im/post/5b23b7cde51d4558b0354ad2 对于 swiper，只要做过轮播图的童鞋应该都再熟悉不过了。这是一个很强大的图片轮播插件，本身无任何第三方库依赖，即插即用。api 文档很清晰，所以很快能够上手。但是，再好的插件也会出现令人不愉快的地方，当然，今天所讨论的并不是插件本身的问题，只是开发者是按照常规做法去使用，而恰好此时出现了令人费解的问题。 原因：在使用 swiper 这个库的时候，一旦设置loop:true的时候，会遇到dom绑定事件无法触发的问题。 踩坑下面来说说我是怎么一步一步采坑并最终解决这个问题的。这里只贴出关键性的代码片段。 第一版： 这是最常规的做法，把 click 事件绑定在 dom 上。但有两点不足之处: click 点击事件有时候无任何反应，并且这种情况必现 点击下面的 title，并不能触发 click 事件，因为并没有绑定 html 代码 123456789101112131415&lt;div class=\"banner\" v-if=\"bannerList.length\"&gt; &lt;swiper :options=\"swiperOption\" ref=\"mySwiper\"&gt; &lt;swiper-slide v-for=\"(banner, index) in bannerList\" :key=\"banner.id\" @click.native=\"handleClickSlide(index)\" &gt; &lt;div class=\"banner-item\"&gt; &lt;img :src=\"banner.imgUrl\" alt=\"news\" /&gt; &lt;p&gt;{{banner.title}}&lt;/p&gt; &lt;/div&gt; &lt;/swiper-slide&gt; &lt;div class=\"swiper-pagination\" slot=\"pagination\"&gt;&lt;/div&gt; &lt;/swiper&gt;&lt;/div&gt; js 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647new Vue({ el: \"#app\", data: function () { return { swiperOption: { // 轮播配置 width: window.innerWidth, autoplay: { delay: 3000, }, loop: true, // 循环滚动 pagination: { // 分页器 el: \".swiper-pagination\", }, preventLinksPropagation: false, // 阻止点击事件冒泡 }, bannerList: [ { id: \"1\", title: \"世界杯揭幕战-超新星1球2助攻俄罗斯5-0沙特 格里兹曼宣布留马竞\", imgUrl: \"http://n.sinaimg.cn/sports/180/w640h340/20180615/AYes-hcyszrz3457297.jpg\", }, { id: \"2\", title: \"颜值满分！世界杯首日美女球迷盘点\", imgUrl: \"http://n.sinaimg.cn/sports/180/w640h340/20180615/H3Wz-hcyszrz4804003.jpg\", }, { id: \"3\", title: \"盘点历届世界杯大比分“屠杀”\", imgUrl: \"http://n.sinaimg.cn/sports/180/w640h340/20180615/FNuk-hcyszrz4805039.jpg\", }, ], }; }, methods: { // 坑在这里： // 会发现有的时候，click 事件点击无反应，而且这种情况是必现的 handleClickSlide(index) { console.log(\"handleClickSlide current index\", index); }, },}); 改良的第二版： 解决了上述两个问题，但同时也存在以下几个问题 常用的 activeIndex （用来标识当前点击的第几张图片），但控制台输出的值是错乱的 左右作切换的时候，activeIndex 的值也是错乱的 html 代码 123456789101112131415&lt;div class=\"banner\" v-if=\"bannerList.length\"&gt; &lt;swiper :options=\"swiperOption\" ref=\"mySwiper\" @click.native=\"handleClickSlide\" &gt; &lt;swiper-slide v-for=\"(banner, index) in bannerList\" :key=\"banner.id\"&gt; &lt;div class=\"banner-item\"&gt; &lt;img :src=\"banner.imgUrl\" alt=\"news\" /&gt; &lt;p&gt;{{banner.title}}&lt;/p&gt; &lt;/div&gt; &lt;/swiper-slide&gt; &lt;div class=\"swiper-pagination\" slot=\"pagination\"&gt;&lt;/div&gt; &lt;/swiper&gt;&lt;/div&gt; js 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455new Vue({ el: \"#app\", data: function () { return { swiperOption: { // 轮播配置 width: window.innerWidth, autoplay: { delay: 3000, }, loop: true, // 循环滚动 pagination: { // 分页器 el: \".swiper-pagination\", }, preventLinksPropagation: false, // 阻止点击事件冒泡 }, bannerList: [ { id: \"1\", title: \"世界杯揭幕战-超新星1球2助攻俄罗斯5-0沙特 格里兹曼宣布留马竞\", imgUrl: \"http://n.sinaimg.cn/sports/180/w640h340/20180615/AYes-hcyszrz3457297.jpg\", }, { id: \"2\", title: \"颜值满分！世界杯首日美女球迷盘点\", imgUrl: \"http://n.sinaimg.cn/sports/180/w640h340/20180615/H3Wz-hcyszrz4804003.jpg\", }, { id: \"3\", title: \"盘点历届世界杯大比分“屠杀”\", imgUrl: \"http://n.sinaimg.cn/sports/180/w640h340/20180615/FNuk-hcyszrz4805039.jpg\", }, ], }; }, computed: { swiper() { return this.$refs.mySwiper.swiper; }, }, methods: { // 坑在这里 // 一开始点击第一张图片，控制台输出的 activeIndex 竟然是 1，难道不应该是 0吗？ // 并且一个循环之后，点击第一张图片， 控制台输出的 activeIndex 竟然变成了 4。。。 handleClickSlide() { // 这个应该是最为想到一个属性，用来标识当前点击图片的索引 const { activeIndex } = this.swiper &amp;&amp; this.swiper; console.log(\"handleClickSlide current index\", activeIndex); }, },}); 最终版 通过 swiper 强大的 api 文档，解决了上述出现的几个问题。关键点在于： 当 loop设置为 true的时候，不能再用 activeIndex或者 clickedIndex。只能用 realIndex。官方的解释为：当前活动块的索引，与activeIndex不同的是，在 loop 模式下不会将复制的块的数量计算在内。 点击事件不能绑定在 dom上 不过稍不注意，也会出现新的坑（代码里有指出） html 代码 1234567891011&lt;div class=\"banner\" v-if=\"bannerList.length\"&gt; &lt;swiper :options=\"swiperOption\" ref=\"mySwiper\"&gt; &lt;swiper-slide v-for=\"(banner, index) in bannerList\" :key=\"banner.id\"&gt; &lt;div class=\"banner-item\"&gt; &lt;img :src=\"banner.imgUrl\" alt=\"news\" /&gt; &lt;p&gt;{{banner.title}}&lt;/p&gt; &lt;/div&gt; &lt;/swiper-slide&gt; &lt;div class=\"swiper-pagination\" slot=\"pagination\"&gt;&lt;/div&gt; &lt;/swiper&gt;&lt;/div&gt; js 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364let vm = null;new Vue({ el: \"#app\", data: function () { return { swiperOption: { // 轮播配置 width: window.innerWidth, autoplay: { delay: 3000, }, loop: true, // 循环滚动 pagination: { // 分页器 el: \".swiper-pagination\", }, on: { click: function () { // 这里有坑 // 需要注意的是：this 指向的是 swpier 实例，而不是当前的 vue， 因此借助 vm，来调用 methods 里的方法 // console.log(this); // -&gt; Swiper // 当前活动块的索引，与activeIndex不同的是，在loop模式下不会将 复制的块 的数量计算在内。 const realIndex = this.realIndex; vm.handleClickSlide(realIndex); }, }, preventLinksPropagation: false, // 阻止点击事件冒泡 }, bannerList: [ { id: \"1\", title: \"世界杯揭幕战-超新星1球2助攻俄罗斯5-0沙特 格里兹曼宣布留马竞\", imgUrl: \"http://n.sinaimg.cn/sports/180/w640h340/20180615/AYes-hcyszrz3457297.jpg\", }, { id: \"2\", title: \"颜值满分！世界杯首日美女球迷盘点\", imgUrl: \"http://n.sinaimg.cn/sports/180/w640h340/20180615/H3Wz-hcyszrz4804003.jpg\", }, { id: \"3\", title: \"盘点历届世界杯大比分“屠杀”\", imgUrl: \"http://n.sinaimg.cn/sports/180/w640h340/20180615/FNuk-hcyszrz4805039.jpg\", }, ], }; }, computed: { swiper() { return this.$refs.mySwiper.swiper; }, }, created() { vm = this; }, methods: { handleClickSlide(index) { console.log(\"handleClickSlide current index\", index); }, },});","link":"/2020/07/04/yuque/swiper%20loop%EF%BC%9Atrue%E5%BC%95%E5%8F%91%E7%BB%91%E5%AE%9Adom%E7%9A%84click%E4%BA%8B%E4%BB%B6%E6%97%A0%E6%95%88%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"redux原理及简单实现","text":"createStore思路：首先 createStore 会接收一个 reducer 来操作 state，然后返回一个 store 对象包含 subscribe、dispatch、getState 方法。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253export default function createStore(reducer, initState) { let state = initState; let listeners = []; // 订阅函数 function subscribe(listener) { listeners.push(listener); } function dispatch(action) { state = reducer(state, action); // 依次执行订阅者 listeners.forEach((listener) =&gt; { listener(); }); } function getState() { return state; } return { subscribe, dispatch, getState };}// 测试代码// 注意要先执行 subscribe，然后再 dispatch，否则当你 dispatch 的时候 listeners 还为空数组const reducer = (state, action) =&gt; { switch (action.type) { case \"addCount\": return { ...state, count: state.count + 1, }; default: return state; }};const initState = { info: { age: 17, }, count: 1,};const store = createStore(reducer, initState);store.subscribe(() =&gt; { console.log(\"subscribe\", store.getState());});store.dispatch({ type: \"addCount\",}); 代码地址：https://codesandbox.io/s/dreamy-banzai-8rptw?file=/src/redux/index.js combineReducers接下来再来实现一个 combineReducers 来颗粒化 reducer，这样我们就可以按组件的维度来拆分出很多个 reducer 函数，然后通过一个函数来把他们合并起来。 颗粒化 reducer代码： 12345678910111213141516export function combineReducers(reducers) { // ['counter', 'info'] const reducerKeys = Object.keys(reducers); return function combination(state = {}, action) { const nextState = {}; reducerKeys.forEach((key) =&gt; { const reducer = reducers[key]; // 之前的state const prevStateForKey = state[key]; // 新的state const nextStateForKey = reducer(prevStateForKey, action); nextState[key] = nextStateForKey; }); return nextState; };} 代码地址：https://codesandbox.io/s/eloquent-ptolemy-9d3s6?file=/src/redux/index.js:400-879 颗粒化 state改写 combineReducers 函数，无非很简单，在 createStore 函数中执行 dispatch({ type: Symbol() })。 1234567891011121314151617181920212223242526export default function createStore(reducer, initState) { let state = initState; let listeners = []; function subscribe(listener) { listeners.push(listener); } function dispatch(action) { state = reducer(state, action); listeners.forEach((listener) =&gt; { listener(); }); } function getState() { return state; } // 只修改了这里，用一个不匹配任何计划的 type，来获取初始值 dispatch({ type: Symbol(), }); return { subscribe, dispatch, getState };} 代码地址：https://codesandbox.io/s/magical-burnell-6e9qq?file=/src/redux/redux2.js 改写之后，我们就可以将 state 分别传入各自的 reducer ： 123456789101112131415161718function counterReducer(state = { count: 1 }, action) { //...}function infoReducer(state = { age: 18 }, action) { //...}// 合并 reducerconst reducers = combineReducers({ counter: counterReducer, info: infoReducer,});// 移除 initStatelet store = createStore(reducers);console.log(store.getState()); // { counter: { count: 1 }, info: { age: 18 } } 颗粒化 state 带来的效果： createStore 的时候，用一个不匹配任何 type 的 action，来触发 state = reducer(state, action) 因为 action.type 不匹配，每个子 reducer 都会进入到 default 项。返回自己初始化的 state，这样就获得了初始化的 state 树了。 redux 中间件所谓中间件，我们可以理解为拦截器，用于对某些过程进行拦截和处理，且中间件之间能够串联使用。这里主要是对 dispatch 的扩展，或者说重写，增强 dispatch 的功能。 实现一个简单 redux-logger 的中间件首先整理下思路，主要就是想实现在 dispatch 之前先去执行一些其他的操作，那么大致实现的代码如下： 1234567891011121314const reducers = combineReducers({ counter: counterReducer });let store = createStore(reducers);const next = store.dispatch;// 重写 dispatchstore.dispatch = (action) =&gt; { console.log(\"prevState: \", store.getState()); console.log(\"action\", action); next(action); console.log(\"nextState: \", store.getState());};store.dispatch({ type: \"INCREMENT\" }); 输出结果如下： prevState: { counter: { count: 1 } }action { type: ‘INCREMENT’ }nextState: { counter: { count: 2 } } 最终，该中间件就简单的实现了。 实现多个中间件的合作那如果又有个需求需要记录每次数据出错的原因呢？那么我们就需要扩展 dispatch 了 123456789101112const reducers = combineReducers({ counter: counterReducer });let store = createStore(reducers);const next = store.dispatch;store.dispatch = (action) =&gt; { try { next(action); } catch (err) { console.error(\"错误报告: \", err); }}; 这样每次 dispatch 出异常的时候，我们都会记录下来。 如果我们需要同时记录日志、并且记录异常该怎么办呢？那么我们就得将两个函数进行合并。 123456789101112131415const reducers = combineReducers({ counter: counterReducer });let store = createStore(reducers);const next = store.dispatch;store.dispatch = (action) =&gt; { try { console.log(\"prevState: \", store.getState()); console.log(\"action\", action); next(action); console.log(\"nextState: \", store.getState()); } catch (err) { console.error(\"错误报告: \", err); }}; 但是显然这种方式是不可行的，因为都是采用类似硬编码的方式进行开发，如果需求多了，那么就得不到很好的扩展性，最终导致 dispatch 函数庞大混乱到无法维护。 那么我们就得考虑如何实现扩展性很强的多中间件合作模式。 首先我们需要将 loggerMiddleware 抽取出来 1234567891011const reducers = combineReducers({ counter: counterReducer });let store = createStore(reducers);const next = store.dispatch;const loggerMiddleware = (action) =&gt; { console.log(\"prevState: \", store.getState()); console.log(\"action\", action); next(action); console.log(\"nextState: \", store.getState());}; 再把 exceptionMiddleware 抽取出来 123456789const exceptionMiddleware = (action) =&gt; { try { /*next(action)*/ loggerMiddleware(action); } catch (err) { console.error(\"错误报告: \", err); }};store.dispatch = exceptionMiddleware; 但是还是存在一个问题，就是 exceptionMiddleware 还是写死了 loggerMiddleware，我们需要让 next(action) 变为动态的，使得随便哪个中间件都可以。 12345678910const exceptionMiddleware = (next) =&gt; (action) =&gt; { try { /*loggerMiddleware(action);*/ next(action); } catch (err) { console.error(\"错误报告: \", err); }};/*loggerMiddleware 变成参数传进去*/store.dispatch = exceptionMiddleware(loggerMiddleware); 同理， loggerMiddleware 里面的 next 现在恒等于 store.dispatch，导致 loggerMiddleware 里面无法扩展到别的中间件了。我们也把 next 写成动态的。 123456const loggerMiddleware = (next) =&gt; (action) =&gt; { console.log(\"this state\", store.getState()); console.log(\"action\", action); next(action); console.log(\"next state\", store.getState());}; 这样，我们就简单的实现了一个扩展性较强的中间件的合作模式了。 12345678910111213141516171819const store = createStore(reducer);const next = store.dispatch;const loggerMiddleware = (next) =&gt; (action) =&gt; { console.log(\"this state\", store.getState()); console.log(\"action\", action); next(action); console.log(\"next state\", store.getState());};const exceptionMiddleware = (next) =&gt; (action) =&gt; { try { next(action); } catch (err) { console.error(\"错误报告: \", err); }};store.dispatch = exceptionMiddleware(loggerMiddleware(next)); 但是上述还是会存在一个问题，就是 loggerMiddleware 包含了外部变量 store，导致我们无法将中间件独立出去。那么很简单、我们就把 store 也作为参数传递进去即可。 123456789101112131415161718192021const store = createStore(reducer);const next = store.dispatch;const loggerMiddleware = (store) =&gt; (next) =&gt; (action) =&gt; { console.log(\"this state\", store.getState()); console.log(\"action\", action); next(action); console.log(\"next state\", store.getState());};const exceptionMiddleware = (store) =&gt; (next) =&gt; (action) =&gt; { try { next(action); } catch (err) { console.error(\"错误报告: \", err); }};const logger = loggerMiddleware(store);const exception = exceptionMiddleware(store);store.dispatch = exception(logger(next)); 现在我有一个需求，在打印日志之前输出当前的时间戳。用中间件来实现！ 1234567const timeMiddleware = (store) =&gt; (next) =&gt; (action) =&gt; { console.log(\"time\", new Date().getTime()); next(action);};const time = timeMiddleware(store);store.dispatch = exception(time(logger(next))); 实现 applyMiddleware上述虽然我们解决了多个中间件的合作的问题，但是对于中间件的使用方式并不是很友好。 123456789101112131415161718192021222324252627let store = createStore(reducers);const next = store.dispatch;const loggerMiddleware = (store) =&gt; (next) =&gt; (action) =&gt; { console.log(\"this state\", store.getState()); console.log(\"action\", action); next(action); console.log(\"next state\", store.getState());};const exceptionMiddleware = (store) =&gt; (next) =&gt; (action) =&gt; { try { next(action); } catch (err) { console.error(\"错误报告: \", err); }};const timeMiddleware = (store) =&gt; (next) =&gt; (action) =&gt; { console.log(\"time\", new Date().getTime()); next(action);};const time = timeMiddleware(store);const logger = loggerMiddleware(store);const exception = exceptionMiddleware(store);store.dispatch = exception(time(logger(next))); 其实我们只需要知道三个中间件，剩下的细节都可以封装起来！我们通过扩展 createStore 来实现！ 先来看看期望的用法 123456789/*接收旧的 createStore，返回新的 createStore*/const newCreateStore = applyMiddleware( exceptionMiddleware, timeMiddleware, loggerMiddleware)(createStore);/*返回了一个 dispatch 被重写过的 store*/const store = newCreateStore(reducer); 实现 applyMiddleware 12345678910111213141516171819202122const applyMiddleware = function (...middlewares) { /*返回一个重写createStore的方法*/ return function rewriteCreateStoreFunc(oldCreateStore) { /*返回重写后新的 createStore*/ return function newCreateStore(reducer, initState) { /*1. 生成store*/ const store = oldCreateStore(reducer, initState); /*给每个 middleware 传下store，相当于 const logger = loggerMiddleware(store);*/ /* const chain = [exception, time, logger]*/ const chain = middlewares.map((middleware) =&gt; middleware(store)); let dispatch = store.dispatch; /* 实现 exception(time((logger(dispatch))))*/ chain.reverse().map((middleware) =&gt; { dispatch = middleware(dispatch); }); /*2. 重写 dispatch*/ store.dispatch = dispatch; return store; }; };}; 现在还有个小问题，我们有两种 createStore 了。 1234567891011/*没有中间件的 createStore*/let store = createStore(reducers, initState);/*有中间件的 createStore*/const rewriteCreateStoreFunc = applyMiddleware( exceptionMiddleware, timeMiddleware, loggerMiddleware);const newCreateStore = rewriteCreateStoreFunc(createStore);const store = newCreateStore(reducer, initState); 为了让用户用起来统一一些，我们可以很简单的使他们的使用方式一致，我们修改下 createStore 方法。 123456789function createStore(reducer, initState, rewriteCreateStoreFunc) { /*如果有 rewriteCreateStoreFunc，那就采用新的 createStore */ if (rewriteCreateStoreFunc) { const newCreateStore = rewriteCreateStoreFunc(createStore); return newCreateStore(reducer, initState); } /*否则按照正常的流程走*/ //...} 最终的用法 123456const rewriteCreateStoreFunc = applyMiddleware( exceptionMiddleware, timeMiddleware, loggerMiddleware);const store = createStore(reducer, initState, rewriteCreateStoreFunc); compose我们的 applyMiddleware 中，把 [A, B, C] 转换成 A(B(C(next)))，是这样实现的 12345const chain = [A, B, C];let dispatch = store.dispatch;chain.reverse().map((middleware) =&gt; { dispatch = middleware(dispatch);}); redux 提供了一个 compose 方式，可以帮我们做这个事情 12const chain = [A, B, C];dispatch = compose(...chain)(store.dispatch); 看下他是如何实现的 123456export default function compose(...funcs) { if (funcs.length === 1) { return funcs[0]; } return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)));} initState有时候我们创建 store 的时候不传 initState，我们怎么用？ 1const store = createStore(reducer, {}, rewriteCreateStoreFunc); redux 允许我们这样写 1const store = createStore(reducer, rewriteCreateStoreFunc); 我们仅需要改下 createStore 函数，如果第二个参数是一个 object，我们认为他是 initState，如果是 function，我们就认为他是 rewriteCreateStoreFunc。 1234567function craeteStore(reducer, initState, rewriteCreateStoreFunc) { if (typeof initState === \"function\") { rewriteCreateStoreFunc = initState; initState = undefined; } //...} 关于中间件及 react-redux，参考文章也有较为详细的讲解。由于中间件部分我觉得原文讲解的挺到位了、所以大部分都是直接摘抄参考文章的。中间件部分个人认为主要理解 applyMiddleware 和 compose。 关于 react-redux，其实根本就是一个 HOC 组件，具体感兴趣的也可以看看参考文章。 参考文章链接：https://juejin.im/post/5b969625e51d450e9704aa99#heading-7","link":"/2020/06/17/yuque/redux%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"},{"title":"taro中的babel配置问题","text":"在一次开发中，使用了 flat 等 es2019 的语法，发现编译之后，flat 为转为 es5 及以下的语法，编译之后还为 flat，就导致了部分用户的机型存在报错。当时开发的时候使用的 taro 版本为 1.3.34。原本是 1.3.25，后来升级到了 1.3.34。于是开启了探索 babel 之路，搜到资料说如下配置即可： 1234567891011{ \"presets\": [ [ \"@babel/preset-env\", { \"useBuiltIns\": \"usage\", \"corejs\": 3 } ] ]} 然后，并没有卵用，按 babel 的解释，这样配置，babel 会自动识别你的语法，然后引入对应语法的 polyfill，即按需引入。 后来又不断搜索资料，查询到 taro 中的 babel 版本为 6，而上述配置为 babel7 的。 后来又尝试全局引入 babel-polyfill，但是查看 babel-polyfill 的 node_modules 发现里面没有 flat，只有 flatten，于是放弃了。后来忘记哪里搜索到，说是最初名字为 flatten，后来修改名字为 flat。而 taro 中 corejs 版本为 2，flat 在 corejs3 中。插曲：vue-cli3 中 使用的 corejs 也是 2，搜索到 vue-cli4 升级了 corejs 为 3 了。 后来查看 taro 文档，https://nervjs.github.io/taro/docs/ui-lib.html#babelconfigjs，说是 babel.config.js 是单测的配置，该 babel 版本是 7。 所以我们只能在 config 目录下去进行编译的配置。 最终解决方案是 flat 使用 reduce 代替，而后 config/index 进行如下配置 123456789101112131415babel: { sourceMap: true, presets: [ ['env', { modules: false, useBuiltIns: true, debug: false }] ], plugins: [ 'transform-decorators-legacy', 'transform-class-properties', 'transform-object-rest-spread' ]}, 然后在 app.tsx 中引入 babel-polyfill(即 import ‘babel-polyfill’;)，因为不确定里面是否也有 flat，所以暂时替换了 flat。 注意：babel 6 中还没 useBuiltIns: ‘usage’，还有 config/index.js 配置完 babel 后直接在 app.tsx 中直接 import ‘babel-polyfill’ 即可，无需再 yarn add babel-polyfill 该操作。 最终给 taro 两个 issue，一是 2.0.0-beta.13 版本 “polyfill”: true 开启报错，二是询问如何配置 flat 等语法。issue 地址：https://github.com/NervJS/taro/issues/5245，https://github.com/NervJS/taro/issues/5246第一个官方的回答是不能开启，有些 polyfill 方式在小程序中无法使用，请按照自己的需求按需引入 polyfill。第二个是 https://www.google.com/search?q=flat+polyfill&amp;oq=flat+polyfi&amp;aqs=chrome.1.69i57j0l7.3913j0j4&amp;sourceid=chrome&amp;ie=UTF-8，自己在项目中引入相关 polyfill。","link":"/2020/07/01/yuque/taro%E4%B8%AD%E7%9A%84babel%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"},{"title":"taro阻止事件冒泡","text":"在用 taro 开发微信小程序的时候，有在 taro 官方交流群遇到个小伙伴说 taro 无法阻止冒泡，后来自己也遇到同样的问题。于是开始排查问题，发现如果你是如下操作： 123456789101112&lt;View onClick={() =&gt; { console.log(\"parent\"); }}&gt; &lt;View onClick={(e) =&gt; { e.stopPropagation(); console.log(\"child\"); }} &gt;&lt;/View&gt;&lt;/View&gt; 你会发现无法正常阻止冒泡，查询编译成微信小程序的代码中只有 bindtap，而小程序中阻止冒泡是得通过 catchtap 来绑定并阻止事件冒泡。于是解决方案如下： 123456789&lt;View onClick={() =&gt; { console.log(\"parent\"); }}&gt; &lt;View onClick={(e) =&gt; e.stopPropagation()}&gt; &lt;View onClick={() =&gt; console.log(\"child\")}&gt;&lt;/View&gt; &lt;/View&gt;&lt;/View&gt; 如此，就可以阻止事件冒泡，且编译出来的代码带有 catchtap 来阻止冒泡。具体可见微信小程序事件机制：https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F","link":"/2020/07/01/yuque/taro%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/"},{"title":"useContext","text":"","link":"/2019/12/01/yuque/useContext/"},{"title":"useEffect和useLayoutEffect","text":"","link":"/2019/12/01/yuque/useEffect%E5%92%8CuseLayoutEffect/"},{"title":"useMemo和useCallback","text":"","link":"/2019/12/01/yuque/useMemo%E5%92%8CuseCallback/"},{"title":"useReducer","text":"","link":"/2019/12/01/yuque/useReducer/"},{"title":"useRef, forwardRef, useImperativeHandle","text":"","link":"/2019/12/01/yuque/useRef,%20forwardRef,%20useImperativeHandle/"},{"title":"useState及其原理","text":"实现一个简单的 useState123456789101112131415161718192021222324252627282930313233343536373839import React from \"react\";import ReactDOM from \"react-dom\";function App() { const [a, setA] = myUseState(0); return ( &lt;div className=\"App\"&gt; &lt;div&gt; &lt;span&gt;{a}&lt;/span&gt; &lt;button onClick={() =&gt; setA(a + 1)}&gt;+&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; );}// 定义一个重渲染函数// 这里我们是简化了react重渲染的// 这样当你更新useState的状态值，通过重渲染来更新UI视图const rerender = () =&gt; { ReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\"));};let _state; // 定义一个state状态值// 使用myUseState函数来模拟useState// 首先传入初始state状态值 - initialState// 判断_state是否为undefined，如果为undefined则取初始值，否则直接使用_state值// 因为_state为更新的状态值，如果未更新的话初始化的时候则默认取传入的initialState// 当调用了setState之后，则更新_state，并进行重渲染来渲染UI视图const myUseState = (initialState) =&gt; { _state = _state === undefined ? initialState : _state; const setState = (newState) =&gt; { _state = newState; rerender(); }; return [_state, setState];};export default App; 代码如上会存在一些问题，首先就是 myUseState 如果定义了多个 state，那么_state 就满足不了了。 如何才可以解决多个 state 状态值的问题呢？加强我们的 myUseState 咯？主要的思路就是给组件每个调用 myUseState 的地方绑定一个内部的 state 值。如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041import React from \"react\";import ReactDOM from \"react-dom\";function App() { const [a, setA] = myUseState(0); const [b, setB] = myUseState(0); return ( &lt;div className=\"App\"&gt; &lt;div&gt; &lt;span&gt;{a}&lt;/span&gt; &lt;button onClick={() =&gt; setA(a + 1)}&gt;+&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;{b}&lt;/span&gt; &lt;button onClick={() =&gt; setB(b + 1)}&gt;+&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; );}const rerender = () =&gt; { ReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\"));};let _state = [];let index = 0;const myUseState = (initialState) =&gt; { const curIndex = index; index++; _state[curIndex] = _state[curIndex] === undefined ? initialState : _state[curIndex]; const setState = (newState) =&gt; { _state[curIndex] = newState; rerender(); }; return [_state[curIndex], setState];};export default App; 然后当你测试的时候你会发现并没有按照我们的思路走。 通过 debug 调试你会发现，初次 render 的时候，App 里面打印出_state 为[0, 0]。然后通过 setA 之后，变成了[1, 0, 0, 0]。 因为在 setA 的时候 _state[curIndex] = newState ，而此时的 curIndex 为 0(其实就是一个闭包吧)，newState 为 1。然后接着往下走 rerender 函数，又调用了两次 myUseState。那么此时在调用 myUseState 这两次之前，index 分别 2，3。 那么你可能有疑问为什么_state 为[1,0,0,0]，而 a 没有更新为 1 呢？因为 rerender 之后，对应的状态值 a,b 都为 0 了。如下所示，步骤 1 即返回给了 a，而步骤 2 返回了 b。**执行如下所示： 12345678910111213141516171819202122232425// 1. setA操作myUseState第一次调用const myUseState = (initialState) =&gt; { const curIndex = index; // curIndex为2了，自行体会下。不难理解 index++; // 下次读取index，他就是3了哦 _state[curIndex] = _state[curIndex] === undefined ? initialState : _state[curIndex]; const setState = (newState) =&gt; { _state[curIndex] = newState; rerender(); }; return [_state[curIndex], setState]; // _state[2]值为0};// 2. myUseState第二次调用const myUseState = (initialState) =&gt; { const curIndex = index; // curIndex 为 3 index++; // 下次读取index，他就是4了哦 _state[curIndex] = _state[curIndex] === undefined ? initialState : _state[curIndex]; const setState = (newState) =&gt; { _state[curIndex] = newState; rerender(); }; return [_state[curIndex], setState]; // _state[3]值为0}; 所以这就是为什么_state 值为[1,0,0,0]的原因了。 那么如何解决呢？ 思路就是在 rerender 之前，将 index 置为 0 就可以对应起来了。 所以将 rerender 修改下即可： 1234const rerender = () =&gt; { index = 0; ReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\"));}; 测试通过。 当然在 react 可不止这么简单，这边只是大致实现的思路。 在 react 内部，其实_state 和 index 都会挂载到 fiberNode 上的对应属性上并进行维护，即链表形式的一种数据结构。 由于其实现机制需要记录次序，所以也就是为什么不可以在条件判断语句中(if)使用 hook 的原因了。 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142import React from \"react\";import ReactDOM from \"react-dom\";function App() { const [a, setA] = myUseState(0); const [b, setB] = myUseState(0); return ( &lt;div className=\"App\"&gt; &lt;div&gt; &lt;span&gt;{a}&lt;/span&gt; &lt;button onClick={() =&gt; setA(a + 1)}&gt;+&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;{b}&lt;/span&gt; &lt;button onClick={() =&gt; setB(b + 1)}&gt;+&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; );}const rerender = () =&gt; { index = 0; ReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\"));};let _state = [];let index = 0;const myUseState = (initialState) =&gt; { const curIndex = index; index += 1; _state[curIndex] = _state[curIndex] === undefined ? initialState : _state[curIndex]; const setState = (newState) =&gt; { _state[curIndex] = newState; rerender(); }; return [_state[curIndex], setState];};export default App; 总结 每个函数组件会对应一个 React 节点 每个节点保存着 state 和 index useState 会读取 state[index] index 由 useState 出现的顺序决定 setState 会修改 state，并触发更新 注意：此内容对 react 实现做了简化，react 节点应该是 FIberNode，_state 真实名称对为 memoizedState，index 实现则用到链表。","link":"/2019/12/01/yuque/useState%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"title":"vscode ts配置","text":"安装与调试配置 npm 淘宝源1npm config set registry https://registry.npm.taobao.org/ 如果后悔了，想撤销淘宝源就运行 npm config delete registry 安装12npm install typescript@2.9.2 -gnpm install ts-node@7.0.0 -g 注意记下 ts-node 安装后的可执行文件路径，后面要用的。 图片链接：https://video.jirengu.com/xdml/image/3ac7c224-c23d-491f-84b5-4fabfbeab9b8/2018-7-16-19-39-47.png 1. 创建 tsdemo/.vscode/launch.json 文件，内容如下: 12345678910111213{ \"configurations\": [ { \"name\": \"ts-node\", \"type\": \"node\", \"request\": \"launch\", \"program\": \"注意看这里，要写成ts-node对应的可执行文件，Windows 用户注意了，你应该写成 ${workspaceRoot}/node_modules/ts-node/dist/bin.js\", \"args\": [\"${relativeFile}\"], \"cwd\": \"${workspaceRoot}\", \"protocol\": \"inspector\" } ]} 2. 打开 tsdemo/1.js，找到调试选项，选择 ts-node，然后点击调试:https://video.jirengu.com/xdml/image/3ac7c224-c23d-491f-84b5-4fabfbeab9b8/2018-7-16-19-41-30.png 3. 然后你就可以看到 console.log(1) 的输入结果了（请确保你选中的是 tsdemo/1.ts）:https://video.jirengu.com/xdml/image/3ac7c224-c23d-491f-84b5-4fabfbeab9b8/2018-7-16-19-45-26.png 参考文章：https://segmentfault.com/a/1190000011935122 tsc 的使用 运行 tsc -w xxx.ts, 实现自动编译 ts 文件 Type Script Compiler 当值为 null 或者 undefined 的时候，可以通过 tsc 的编译，即绕过了 ts 的类型检查。 用 TS 开发命令行程序最简单的命令行程序1.ts 12#!/usr/bin/env ts-nodeconsole.log(\"hello world\"); 然后给该文件添加执行权限：`chmod +x ./1.ts （Windows 用户不需要做这个，直接在 Git Bash 输入 ./1.ts 即可运行） 执行 ./1.ts 就会看到 hello world 接受命令行参数2.ts 12#!/usr/bin/env ts-nodeconsole.log(process.argv); 如果没有配置好 TS，那么运行 ./2.ts 上面代码会出现如下报错： 12345678910111213141516/usr/local/lib/node_modules/ts-node/src/index.ts:261 return new TSError(diagnosticText, diagnosticCodes) ^TSError: ⨯ Unable to compile TypeScript:2.ts(2,13): error TS2304: Cannot find name 'process'. at createTSError (/usr/local/lib/node_modules/ts-node/src/index.ts:261:12) at getOutput (/usr/local/lib/node_modules/ts-node/src/index.ts:367:40) at Object.compile (/usr/local/lib/node_modules/ts-node/src/index.ts:557:11) at Module.m._compile (/usr/local/lib/node_modules/ts-node/src/index.ts:439:43) at Module._extensions..js (module.js:663:10) at Object.require.extensions.(anonymous function) [as .ts] (/usr/local/lib/node_modules/ts-node/src/index.ts:442:12) at Module.load (module.js:565:32) at tryModuleLoad (module.js:505:12) at Function.Module._load (module.js:497:3) at Function.Module.runMain (module.js:693:10) 报错说得很清楚，2.ts(2,13): error TS2304: Cannot find name ‘process’. 找不到 process。 实际上这是 Node.js 的全局变量，不可能找不到。 这就是 TS 的厉害之处：如果你不告诉我 process 是什么，我就不允许你用 process。 那么如何告诉 TS process 是什么呢？ 方法如下： 1234567# 初始化项目的 package.json&gt; npm init -y# 安装 node 相关的类型定义&gt; npm install @types/node# 再次运行 ./2.ts&gt; ./2.ts[ 'node', '/Users/frank/TypeScript/tsdemo/2.ts' ] 就可以了。 那么 @types/node 到底定义了什么呢？打开 ./node_modules/@types/node/globals.d.ts 搜索 Process 就能看到 process 的定义了： 12345678910export interface Process extends EventEmitter { stdout: WriteStream; stderr: WriteStream; stdin: ReadStream; openStdin(): Socket; argv: string[]; argv0: string; execArgv: string[]; execPath: string; ... 四则运算12345678910const a: number = parseInt(process.argv[2]);const b: number = parseInt(process.argv[3]);if (Number.isNaN(a) || Number.isNaN(b)) { console.log(\"输入不合法\"); // return; // 有问题 // 成功则返回 0， 失败则返回非 0。 process.exit(2);}console.log(a + b);process.exit(0); return 这句话有问题，因为不能在顶级作用域运行 return，如果我们需要退出程序，只能使用 process.exit(N)，其中的 N 是返回值。 配置 ts 的 es6 环境, 新建 tsconfig.json, 配置如下: 12345{ \"compilerOptions\": { \"lib\": [\"es2015\"] }}","link":"/2020/07/04/yuque/vscode%20ts%E9%85%8D%E7%BD%AE/"},{"title":"「递归」和「迭代」","text":"首先搜索 Wiki 会得到对「递归」和「迭代」的定义: 递归: **又译为递回。**是指在函数的定义中使用函数自身的方法。递归一词还较常用于描述以自相似方法重复事物的过程。例如，当两面镜子相互之间近似平行时，镜中嵌套的图像是以无限递归的形式出现的。也可以理解为自我复制的过程。 迭代: 迭代是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果会被用来作为下一次迭代的初始值。 迭代是逐渐逼近，用新值覆盖旧值，直到满足条件后结束，不保存中间值，空间利用率高。 递归是将一个问题分解为若干相对小一点的问题，遇到递归出口再原路返回，因此必须保存相关的中间值，这些中间值压入栈保存，问题规模较大时会占用大量内存。 白话翻译:递归：你自己不太了解小孩子的需求，为了缩小范围，让你的儿子去给孙子挑选。儿子比你强点有限，但依然不太了解小孩子的需求。为了缩小范围，你又让你孙子去挑选。如此这般，直到找到合适的玩具。迭代：你挑了一件觉得不行，又挑了一件又不行。如此这般，直到找到合适的玩具。所以一句话：递归是自己调用自己，每次旨在缩小问题规模。迭代是自己执行很多次，每次旨在更接近目标。(摘自知乎回答 https://www.zhihu.com/question/20278387) 接下来就是上代码: 123456789// 斐波那契数列索引位置: 1 2 3 4 5 6 7 8 ...对应的值: 1 1 2 3 5 8 13 21 ...// 首先用递归的方式function fib(n) { if (n === 1 || n === 2) return 1; return fib(n - 1) + fib(n - 2);} 当你采用递归的方式，你跑在 node 或者 浏览器中当 n 为 1000 或者更大值时，会提示爆栈或者执行速度极其之慢。因为此时的时间复杂度为 O(n^2)。 图解递归执行: 由此不难看出存在许多的重复执行，所以时间复杂度更大，执行耗时也更长。 使用迭代的方式: 1234567891011121314151617function fib(n) { const fibArr = []; for (let i = 0; i &lt; n; i++) { if (i === 0 || i === 1) fibArr.push(1); else fibArr.push(fibArr[fibArr.length - 1] + fibArr[fibArr.length - 2]); } return fibArr[fibArr.length - 1];}// 尾递归 - 一般尾递归也是迭代function fib(n, ac1 = 1, ac2 = 1) { if (n &lt;= 2) { return ac2; } return fib(n - 1, ac2, ac1 + ac2);} 不难看出，迭代是层层递进，逐步接近目标。 第一种方法：此时的时间复杂度为 O(n) 了，空间复杂度也为 O(n)，相当于用空间换时间。此时执行 n 为 1000 及更大的数值时，极大提升了执行速度。 第二种方法：fib(6) -&gt; fib(6, 1, 1) -&gt; fib(5, 1, 2) -&gt; fib(4, 2, 3) -&gt; fib(3, 3, 5) -&gt; fib(2, 5, 8) -&gt; 得出 fib(6) 值为 8。 简而言之，「递归」即为不断重复自我，先递进(展开)，再回归(求值)。「迭代」即为不断接近目标。","link":"/2020/03/03/yuque/%E3%80%8C%E9%80%92%E5%BD%92%E3%80%8D%E5%92%8C%E3%80%8C%E8%BF%AD%E4%BB%A3%E3%80%8D/"},{"title":"为什么react建议在componentDidMount生命周期中发请求","text":"之后面试的时候，有遇到面试官问过这个问题，当时忘记哪里看到的文章说是 componentWillMount 调用在 constructor 后，在这里的代码调用 setState 不会出发重新渲染，所以不用。于是后续自己整理下。在 codesandbox 写了例子测试，发现看到的文章解释貌似是错误的(其实貌似可以去掉了，这个说法就是错误的)。例子如下：https://codesandbox.io/s/stoic-agnesi-o6hxh具体代码： 12345678910111213141516171819202122232425import React from \"react\";import ReactDOM from \"react-dom\";import \"./styles.css\";class App extends React.Component { state = { count: 0, }; componentWillMount() { setTimeout(() =&gt; { this.setState({ count: 666, }); }, 3000); } render() { return &lt;div&gt;{this.state.count}&lt;/div&gt;; }}const rootElement = document.getElementById(\"root\");ReactDOM.render(&lt;App /&gt;, rootElement); 你会发现 count 渲染的值发生了变化哦，所以不会出发重新渲染这个说法完全就是 ❌ 的。 参考：https://juejin.im/post/5c70e67f6fb9a049ba42326b#heading-2至于前面说到的数据在组件挂载前返回导致不生效的，这种情况并不会发生, 因为 setState 是将更新的状态放进了组件的__pendingStateQueue 队列中，react 并不会立即响应更新，会等到组件挂载完成后，再统一更新脏组件见下图 之后又在掘金搜索了相关文章，总结如下： componentWillMount 已经为 unsafe 的生命周期了，意味着 react 即将在后续版本移除该生命周期。具体见: https://zh-hans.reactjs.org/docs/react-component.html#unsafe_componentwillmount 跟服务端渲染有关系（同构），如果在 componentWillMount 里获取数据，fetch data 会执行两次，一次在服务端一次在客户端，使用 componentDidMount 则没有这个问题。 ssr: 服务端渲染会执行两次 willMount，一次在服务端，之后返回 client 端后再一次 render string 形式的 dom。而在 willMount 中是拿不到数据 - 在服务端使用 rendertoString 渲染组件时，生命周期只会执行到 willMount 之后第一次 render，在 willMount 内部，异步的数据都没有获取到，这个时候 renderToString 就已经返回了。那我们页面的初始化数据就没有了，而返回的 HTML 不是我们所期望的。因此一般会定义一个静态方法，在组件实例化之前获取到这个方法，同步执行，数据获取完成后，通过 props 把数据传入给组件进行渲染。(这段 ssr 的相关解释摘自饥人谷 react 轮子班的一个大佬的笔记)参考：https://daveceddia.com/where-fetch-data-componentwillmount-vs-componentdidmount/ 请求是异步的，所以你无论在 willMount 还是 didMount 都避免不了触发二次渲染。 react fiber 机制影响，willMount 可能会触发多次。 参考文章: https://zhuanlan.zhihu.com/p/26027085总的来说，在 React Fiber 中，一次更新过程会分成多个分片完成，所以完全有可能一个更新任务还没有完成就被另一个更高优先级的更新过程打断，这时候，优先级高的更新任务会优先处理完，而低优先级更新任务所做的工作则会完全作废，然后等待机会重头再来。 因为一个更新过程可能被打断，所以 React Fiber 一个更新过程被分为两个阶段(Phase)：第一个阶段 Reconciliation Phase 和第二阶段 Commit Phase。 在第一阶段 Reconciliation Phase，React Fiber 会找出需要更新哪些 DOM，这个阶段是可以被打断的；但是到了第二阶段 Commit Phase，那就一鼓作气把 DOM 更新完，绝不会被打断。 以 render 函数为界，第一阶段可能会调用下面这些生命周期函数，说是“可能会调用”是因为不同生命周期调用的函数不同。 componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate 下面这些生命周期函数则会在第二阶段调用。 componentDidMount componentDidUpdate componentWillUnmount 所以 fiber 机制意味着 willMount 可能存在被打断的问题，存在被重复调用多次的问题哦~。 其实，抛去上述的问题，个人觉得主要还是规范化吧，具体放在哪个生命周期因业务场景需要而异吧。从另外的角度看，放在 constructor 或者 componentWillMount 里面反而会更加有效率。比如你组件过于庞大了，放在 constructor 或者 componentWillMount 反而会提交效率。所以，总结如上，但是具体因人因业务因使用场景而异。","link":"/2020/01/05/yuque/%E4%B8%BA%E4%BB%80%E4%B9%88react%E5%BB%BA%E8%AE%AE%E5%9C%A8componentDidMount%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E5%8F%91%E8%AF%B7%E6%B1%82/"},{"title":"其他","text":"","link":"/2020/07/25/yuque/%E5%85%B6%E4%BB%96/"},{"title":"云服务器部署Node服务项目","text":"首先登录云服务器，然后通过对应命令安装 git，nginx，pm2，nodejs，mongodb 等 安装后，通过 git clone 命令将项目从 github/gitlab 等代码托管平台上拉取代码到云服务器上。 我这边是 clone 到 / 目录下，我的项目是 imooc_zhihu_api ，然后 cd 到该目录下(/imooc_zhihu_api) 。运行 yarn 或者 npm i 安装依赖，然后再执行 package.json 中对应的 script 的命令启动该项目。此处我的是 npm run start 。启动之后，当你访问服务器的 ip 地址的时候，即可访问该项目的服务。 然后这有个缺陷就是退出了该服务就挂了，所以得有个进行守护，通过运行 pm2 start npm --name imooc_zhihu_api_server -- start 即可后台运行该服务。参考：https://www.jianshu.com/p/7b7378deb3e5 然后我不想直接访问根路径去访问到我的项目，于是需要进行 nginx 的配置，通过 nginx -t 命令查到 nginx 默认配置文件位于 /etc/nginx/nginx.conf 。 然后配置 location 改为如下： 123location /imooc_zhihu_api_server/ { proxy_pass http://127.0.0.1:8080/;} 因为我 imooc_zhihu_api 项目是在 8080 端口上的，所以该处的配置我是将 http 默认的端口 80 转发 8080 端口。 注意此处 uri 的规则匹配，之前踩了坑是 / 这个斜杠没匹配正确导致一直 404，参考文章：https://blog.csdn.net/iamlihongwei/article/details/77881955 配置之后，重启 nginx 即可， systemctl restart nginx 。 这样你就可以通过 ip 地址/imooc_zhihu_api_server 来访问该服务。 个人部署的时候遇到的几个需要注意的点： 安全组对应的端口是否开放，如果未开放你是访问不了的 nginx 的 location 配置规则 云服务器上数据库是否启动，且安全组是否开放了对应的端口访问 pm2 运行 package.json 的 script 中的命令，即以 npm 的形式运行项目","link":"/2020/05/04/yuque/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2Node%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/"},{"title":"初始化state，includes语法ts提示报错","text":"代码片段如下： ) 如上图所示，提示 activeValue 会为 never 类型。 初始化 state，要在 constructor。如图这样初始化，就会推断 never。 所以按如下方式修改即可： 12345678class XXX extends React.Component&lt;XXXProps, XXXState&gt; { constructor(props) { super(props); this.state = { activeValue: [......] }; }} 大致如上所示。","link":"/2020/07/01/yuque/%E5%88%9D%E5%A7%8B%E5%8C%96state%EF%BC%8Cincludes%E8%AF%AD%E6%B3%95ts%E6%8F%90%E7%A4%BA%E6%8A%A5%E9%94%99/"},{"title":"合成事件和原生事件","text":"简介在 React 中，事件 event 是一个合成事件，React 根据 W3C 规范来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。 SyntheticEvent(合成事件)实例将被传递给你的事件处理函数，它是浏览器的原生事件的跨浏览器包装器。除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()。 当你需要使用浏览器的底层事件时，只需要使用 nativeEvent 属性来获取即可。 每个 SyntheticEvent 对象都包含以下属性： 1234567891011121314boolean bubblesboolean cancelableDOMEventTarget currentTargetboolean defaultPreventednumber eventPhaseboolean isTrustedDOMEvent nativeEventvoid preventDefault()boolean isDefaultPrevented()void stopPropagation()boolean isPropagationStopped()DOMEventTarget targetnumber timeStampstring type 实际上，React 的合成事件系统只是原生 DOM 事件系统的一个子集。它仅仅实现了 DOM Level 3 的事件接口，并且统一了浏览器间的兼容问题。有些事件 React 并没有实现或者受某些限制没办法去实现，比如 window 的 resize 事件。 对于无法使用 React 合成事件的场景，我们还需要使用原生事件来完成。 对比浏览器原生 DOM 事件的传播可以分为 3 个阶段：事件捕获阶段，目标对象本身的事件处理程序调用以及事件冒泡。事件捕获在程序开发中的意义并不大，且它的兼容性的问题，所以 React 的合成事件并没有实现事件捕获，仅仅支持了事件冒泡机制。注意：不要将合成事件与原生事件混用，因为这样你会发现 event.stopPropagation() 是阻止不了冒泡的，而且 reactEvent.nativeEvent.stopPropagation() 也是同样阻止不了。 上 Demo: 123456789101112131415161718192021222324252627import * as React from \"react\";import { render } from \"react-dom\";import \"./styles.css\";/** * 正常操作，正常阻止冒泡 * 都是合成事件 */function App() { const appClick = (e) =&gt; { console.log(\"appClick\"); }; const h1Click = (e) =&gt; { e.stopPropagation(); console.log(\"h1Click\"); }; return ( &lt;div className=\"App\" onClick={appClick}&gt; &lt;h1 onClick={h1Click}&gt;Hello CodeSandbox&lt;/h1&gt; &lt;h2&gt;Start editing to see some magic happen!&lt;/h2&gt; &lt;/div&gt; );}const rootElement = document.getElementById(\"root\");render(&lt;App /&gt;, rootElement); 12345678910111213141516171819202122232425262728293031import * as React from \"react\";import { render } from \"react-dom\";import \"./styles.css\";/** * 都阻止不了冒泡 * 父 - 原生事件，子 - 合成事件 */function App() { React.useEffect(() =&gt; { document.querySelector(\".App\").addEventListener(\"click\", (e) =&gt; { console.log(\"appClick\"); }); }, []); const h1Click = (e) =&gt; { e.stopPropagation(); // 阻止不了 // e.nativeEvent.stopPropagation(); // 同样阻止不了 console.log(\"h1Click\"); }; return ( &lt;div className=\"App\"&gt; &lt;h1 onClick={h1Click}&gt;Hello CodeSandbox&lt;/h1&gt; &lt;h2&gt;Start editing to see some magic happen!&lt;/h2&gt; &lt;/div&gt; );}const rootElement = document.getElementById(\"root\");render(&lt;App /&gt;, rootElement); 1234567891011121314151617181920212223242526272829import * as React from \"react\";import { render } from \"react-dom\";import \"./styles.css\";/** * 阻止了冒泡 * 父 - 合成事件，子 - 原生事件 */function App() { const appClick = (e) =&gt; { console.log(\"appClick\"); }; React.useEffect(() =&gt; { document.querySelector(\"h1\").addEventListener(\"click\", (e) =&gt; { console.log(\"h1 click\"); e.stopPropagation(); }); }, []); return ( &lt;div className=\"App\" onClick={appClick}&gt; &lt;h1&gt;Hello CodeSandbox&lt;/h1&gt; &lt;h2&gt;Start editing to see some magic happen!&lt;/h2&gt; &lt;/div&gt; );}const rootElement = document.getElementById(\"root\");render(&lt;App /&gt;, rootElement); 注：demo 中的 document.xxx 选中 dom 元素方法均可改成 ref 去获取 dom 元素(推荐)。 所以得出结论：阻止 React 事件冒泡的行为只能用于 React 合成事件系统中，且没办法阻止原生冒泡行为。反之，在原生事件中的阻止冒泡行为可以阻止 React 合成事件的传播。","link":"/2019/12/27/yuque/%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6/"},{"title":"命名函数表达式 VS 匿名函数表达式","text":"原文地址：https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20%26%20object%20prototypes/ch6.md#%E6%B2%A1%E6%9C%89%E8%AF%8D%E6%B3%95 匿名函数表达式的缺点： 使调试时的栈追踪变得困难 使自引用（递归，事件绑定等）变得困难 使代码（稍稍）变得难于理解 然后在简明方法中： 12345678var Foo = { bar: function () { /*..*/ }, // 简明方法 baz: function baz() { /*..*/ },}; 第一和第三条不适用于简明方法。 虽然去掉语法糖使用 匿名函数表达式 一般会使栈追踪中没有 name。简明方法在语言规范中被要求去设置相应的函数对象内部的 name 属性，所以栈追踪应当可以使用它（这是依赖于具体实现的，所以不能保证）。 然而，第二条 仍然是简明方法的一个缺陷。 它们不会有词法标识符用来自引用。考虑： 1234567891011121314var Foo = { bar: function (x) { if (x &lt; 10) { return Foo.bar(x * 2); } return x; }, baz: function baz(x) { if (x &lt; 10) { return baz(x * 2); } return x; },}; 在这个例子中上面的手动 Foo.bar(x*2) 引用就足够了，但是在许多情况下，一个函数不一定能够这样做，比如使用 this 绑定，函数在委托中被分享到不同的对象，等等。你将会想要使用一个真正的自引用，而函数对象的 name 标识符是实现的最佳方式。 只要小心简明方法的这个注意点，而且如果当你陷入缺少自引用的问题时，仅仅为这个声明 放弃简明方法语法，取代以手动的 命名函数表达式 声明形式：baz: function baz(){..}。","link":"/2020/07/17/yuque/%E5%91%BD%E5%90%8D%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%20VS%20%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"安装husky后跑script命令默认先跑单测","text":"在安装 husky 后，package.json 的配置为如下： 12345678\"husky\": { \"hooks\": { \"pre-commit\": \"lint-staged\" }},\"lint-staged\": { \"**/*.{js,jsx,ts,tsx}\": \"eslint\"}, 众所周知，这样配置应该是 commi 的时候 eslint 检测暂存区中的代码是否符合 eslint 规则，然后测试了好几次，发现默认竟然是先跑了单测测试。 后来通过删除 node_modules，然后再执行 yarn 命令，恢复正常(达到预期效果)。所以个人推测是 node_modules 缓存问题，或者是 husky 的包有 bug 或者啥的，感兴趣的话可以去 github 查看有没有相关的 issue 或者 pr。 后来搜索，发现存在 npm 缓存的情况，当清 node_modules 出现某一些包错误时候，查不到原因时候，可以适当的清除缓存试试。删掉重新安装。 执行如下命令: 123$ rm -rf node_modules$ npm cache clean 或者 npm cache clean -f$ npm install","link":"/2020/07/01/yuque/%E5%AE%89%E8%A3%85husky%E5%90%8E%E8%B7%91script%E5%91%BD%E4%BB%A4%E9%BB%98%E8%AE%A4%E5%85%88%E8%B7%91%E5%8D%95%E6%B5%8B/"},{"title":"实现swiper改动之显示三个滑块，左右两个滑块露出一部分","text":"做轮播图的时候，第一时间想到的就是用 swiper 这个插件。 最近做的项目中需要实现显示三个滑块，左右两个滑块露出一部分。 如下图： 可看到不仅只是滑动，还需要同时显示三个，中间一个全部显示，左右两个露出一部分，让用户看到，然后知道可以滑动。 普通的 swiper 只能满足于一个个 100%宽度显示然后滑动，这就需要修改 swiper 的样式部分了，具体 css 代码如下： 123456789101112/* 轮播定制化 --begin*/.storeActivity-list .swiper-slide { width: 90% !important; margin: 0 5%;}.swiper-slide-prev { right: -8%;}.swiper-slide-next { left: -8%;}/* 轮播定制化 --end*/ 由于个人项目用的 vue， 光这样写的话如果默认展示第一张左右是没有图片的，所以设置: 123swiperOption: { loop: true,} 这样就可以循环看了。","link":"/2020/07/04/yuque/%E5%AE%9E%E7%8E%B0swiper%E6%94%B9%E5%8A%A8%E4%B9%8B%E6%98%BE%E7%A4%BA%E4%B8%89%E4%B8%AA%E6%BB%91%E5%9D%97%EF%BC%8C%E5%B7%A6%E5%8F%B3%E4%B8%A4%E4%B8%AA%E6%BB%91%E5%9D%97%E9%9C%B2%E5%87%BA%E4%B8%80%E9%83%A8%E5%88%86/"},{"title":"小程序seek导致的onTimeUpdate失效","text":"在做小程序项目的时候，有需求是需要获取音频实时播放的时间与后端返回数据的时间做比对，然后跳转到指定时间点做对应的动效。于是翻了小程序的文档，通过 wx.createInnerAudioContext()创建音频上下文，然后监听 onTimeUpdate 事件获取实时播放进度。但是发现微信开发者工具上调试该监听事件未执行，查阅了社区说是得添加 autoplay 为 true 才可以使得 onTimeUpdate 正常执行，尝试了之后发现确实可以了。但是又发现 seek 之后音频在暂停了，于是又搜索相关资料，尝试了 onPlay 回调中添加 play 去执行。测试通过，但是后面测试同学测试的时候，发现 ios 正常，安卓手机每次 seek 之后 play 就会从头开始播放。又去社区上寻找答案，发现有人提过 seek 之后音频暂停的问题。后来调试发现，将 autoplay=true 去掉之后，seek 之后直接 play，虽然在模拟器上 onTimeUpdate 没效果，但是安卓和 ios 上测试均正常执行，于是问题解决了。","link":"/2020/07/01/yuque/%E5%B0%8F%E7%A8%8B%E5%BA%8Fseek%E5%AF%BC%E8%87%B4%E7%9A%84onTimeUpdate%E5%A4%B1%E6%95%88/"},{"title":"微信分享踩坑汇总","text":"关于微信分享踩过的坑个人进行如下汇总整理: 微信分享是通过调用微信的 sdk 去进行分享功能。 根据微信公众平台文档方法，我们采用的方案是通过调用后端的接口去获取微信配置所需参数，然后调取微信 sdk 的 api 进行分享操作。 请求后端接口的时候需要参数 url，url 后面的参数要进行如下方式进行编码 1url = encodeURIComponent(location.href).split(\"#\")[0]; 否则你获取到的配置去进行 wx.config 配置的时候就无法正常分享，按照文档开启 wx.config({debug: true})即可查看报错信息。 此处为个人猜想：个人测试在测试环境下(使用测试公众号)分享非同域的链接分享也不起作用，因为测试代码如下，link 为非同域域名下分享调用不成功，改为同域即可。 123456789101112wx.ready(function () { //需在用户可能点击分享按钮前就先调用 wx.updateAppMessageShareData({ title: \"\", // 分享标题 desc: \"\", // 分享描述 link: \"xx.xxxx.com(随意非同域域名)\", // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: \"\", // 分享图标 success: function () { // 设置成功 }, });}); 由于 ios 端和 android 端分享机制不一致，导致分享失败，后经排查，ios 分享的 imgUrl 的图片大小有限制。搜了资料说是不能超过 30 多 k，个人测试 200 多 k 的时候还是有问题，压缩至 100 多 k 的时候问题解决。具体机制未去了解。 4) 测试通过接口获取分享的 url 时，在微信开发者工具里面发现分享出去的 url 会进行自动 encodeURIComponent，导致真机分享失败。通过对自动 encodeURIComponent 的 url 进行 decodeURIComponent 解码即可。","link":"/2020/07/04/yuque/%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB%E8%B8%A9%E5%9D%91%E6%B1%87%E6%80%BB/"},{"title":"微信支付","text":"可直接访问微信公众平台技术文档: https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115 配置好后，使用方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445function onBridgeReady(data, cb, errorCb) { WeixinJSBridge.invoke( \"getBrandWCPayRequest\", { appId: `${data.appId}`, //公众号名称，由商户传入 timeStamp: `${data.timeStamp}`, //时间戳，自1970年以来的秒数 nonceStr: data.nonceStr, //随机串 package: `prepay_id=${data.package}`, signType: \"MD5\", //微信签名方式： paySign: data.paySign, //微信签名 }, function (res) { if (res.err_msg == \"get_brand_wcpay_request:ok\") { // 使用以上方式判断前端返回,微信团队郑重提示： //res.err_msg将在用户支付成功后返回ok，但并不保证它绝对可靠。 cb(); } else { errorCb(); } } );}const wexinPay = function (data, cb, errorCb) { if (typeof WeixinJSBridge == \"undefined\") { if (document.addEventListener) { document.addEventListener( \"WeixinJSBridgeReady\", function () { onBridgeReady(data, cb, errorCb); }, false ); } else if (document.attachEvent) { document.attachEvent(\"WeixinJSBridgeReady\", function () { onBridgeReady(data, cb, errorCb); }); document.attachEvent(\"onWeixinJSBridgeReady\", function () { onBridgeReady(data, cb, errorCb); }); } } else { onBridgeReady(data, cb, errorCb); }}; 注：JS API 的返回结果 get_brand_wcpay_request:ok 仅在用户成功完成支付时返回。由于前端交互复杂，get_brand_wcpay_request:cancel 或者 get_brand_wcpay_request:fail 可以统一处理为用户遇到错误或者主动放弃，不必细化区分。 在调用的时候发现提示 {&quot;errMsg&quot;:&quot;chooseWXPay:fail&quot;} 解决方法: 微信支付授权目录一定要配置到最后一层 授权目录的配置地址是：微信商户平台 &gt; 产品中心 &gt; 开发配置 比如：调用 chooseWXPay 的 JSSDK 的页面地址为 http://www.bigfoot.xin/weixin/pay/test.html, 那么授权目录需要配置为 http://www.bigfoot.xin/weixin/pay/, 如果只是配置成 http://www.bigfoot.xin/weixin/ 将报错 温馨提示: 注意参与生成签名的有 appId, timeStamp, nonceStr, package, signType, 注意大小写 😯","link":"/2020/07/04/yuque/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"},{"title":"微信浏览器中如何阻止下拉查看网址","text":"在做微信浏览器的 h5 项目的时候，有个需求需要某个元素上滑和下滑。 然而在下滑的时候，发现整个文档都跟着下滑了。 通过 Google 搜索，使用如下方案解决： 1234567document.body.addEventListener('touchmove', (event) =&gt; { event.preventDefault()})// 个人将这方法改为如下方案了body { touch-aciton: none} 后测试发现 IOS 中无效，且还发现 body { overflow: hidden }也无效。 于是又进行了 Google，采用如下方案解决: 12345html { width: 100%; height: 100%; position: fixed;} 此时，整个文档就固定住了，而且滑动的元素超出后也会消失。 整套方案代码如下： 123456789101112html { width: 100%; height: 100%; position: fixed;}body { overflow: hidden; width: 100%; height: 100%; touch-action: none;}","link":"/2020/07/04/yuque/%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%B8%8B%E6%8B%89%E6%9F%A5%E7%9C%8B%E7%BD%91%E5%9D%80/"},{"title":"悬停鼠标显示方法详细信息","text":"参考：https://blog.csdn.net/qq_34033853/article/details/86263014 偶然发现 ws 鼠标悬浮在 vue 文件的 v-for 上可以显示其详细信息，如图所示：开启方法：搜索 *Show quick documentation on mouse move *勾选中即可。注：不同版本的 ws 可能改配置的位置不同，我的是在 Webstorm-&gt;Preferences-&gt;Editor-&gt;Code Editing-&gt;Quick Documentation 处。","link":"/2020/05/12/yuque/%E6%82%AC%E5%81%9C%E9%BC%A0%E6%A0%87%E6%98%BE%E7%A4%BA%E6%96%B9%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF/"},{"title":"浏览器中的 ECMAScript模块","text":"原文地址：https://jakearchibald.com/2017/es-modules-in-browsers/ 兼容ES 模块现在可在浏览器中使用！兼容性如下图： 代码演示1234&lt;script type=\"module\"&gt; import {addTextToBody} from './utils.mjs'; addTextToBody('Modules are pretty cool.');&lt;/script&gt; 123456// utils.mjsexport function addTextToBody(text) { const div = document.createElement(\"div\"); div.textContent = text; document.body.appendChild(div);} 点看查看 Demo 演示 您只需要在 script 元素上输入 type = module，浏览器就会将内联脚本或外部脚本视为 ECMAScript 模块。 关于模块的文章已经很多，但是我想分享一些我在测试和阅读规范时学到的关于浏览器的知识： 当前不支持“裸”导入说明符123456789// 支持:import { foo } from \"https://jakearchibald.com/utils/bar.mjs\";import { foo } from \"/utils/bar.mjs\";import { foo } from \"./bar.mjs\";import { foo } from \"../bar.mjs\";// 不支持:import { foo } from \"bar.mjs\";import { foo } from \"utils/bar.mjs\"; 有效的模块说明符必须与以下之一匹配： 完整的非相对 URL。与之类似，通过新的 URL（moduleSpecifier）放置时不会引发错误。 以 / 开始。 以 ./ 开始。 以 ../ 开始。 其他说明符保留供将来使用，例如导入内置模块。 nomodule 向后兼容点击查看 Demo 演示 了解 type = module 的浏览器应忽略具有 nomodule 属性的脚本。这意味着您可以将模块树提供给支持模块的浏览器，同时提供对其他浏览器的回退。 浏览器问题： Firefox 不支持 nomodule（问题）。已修复！ Edge 不支持 nomodule（问题）。已在 Edge 16 中修复！ Safari 10.1 不支持 nomodule。已在 Safari 11 中修复！对于 10.1，有一个非常聪明的解决方法。 默认延迟12345678&lt;! -- 2 --&gt;&lt;script type=\"module\" src=\"1.mjs\"&gt;&lt;/script&gt;&lt;! -- 1 --&gt;&lt;script src=\"2.js\"&gt;&lt;/script&gt;&lt;! -- 3 --&gt;&lt;script defer src=\"3.js\"&gt;&lt;/script&gt; 点击查看 Demo 演示 顺序应为 2.js，1.mjs，3.js。 脚本在获取过程中阻止 HTML 解析器的方式是非常不好的。使用常规脚本，您可以使用 defer 来防止阻塞，这也可以延迟脚本执行，直到文档完成解析为止，并与其他延迟脚本保持执行顺序。默认情况下，模块脚本的行为类似于 defer - 无法使模块脚本在 HTML 解析器获取时阻止它。 模块脚本与使用 defer 的常规脚本使用相同的执行队列。 内联脚本也被推迟123456789101112131415&lt;!-- 3 --&gt;&lt;script type=\"module\"&gt; addTextToBody(\"Inline module executed\");&lt;/script&gt;&lt;!-- 1 --&gt;&lt;script src=\"1.js\"&gt;&lt;/script&gt;&lt;!-- 2 --&gt;&lt;script defer&gt; addTextToBody(\"Inline script executed\");&lt;/script&gt;&lt;!-- 4 --&gt;&lt;script defer src=\"2.js\"&gt;&lt;/script&gt; 点击查看 Demo 演示 顺序应为 1.js，inline script，inline module，2.js。 常规的内联脚本忽略延迟，而内联模块脚本则始终延迟，无论它们是否导入任何内容。 异步适用于外部和内联模块123456789&lt;!-- 导入完成后立即执行 --&gt;&lt;script async type=\"module\"&gt; import {addTextToBody} from './utils.mjs'; addTextToBody('Inline module executed.');&lt;/script&gt;&lt;!-- 此操作一经执行，其导入内容便已获取 --&gt;&lt;script async type=\"module\" src=\"1.mjs\"&gt;&lt;/script&gt; 点击查看 Demo 演示 fast-downloading 脚本应该在 the slow 之前执行。 与常规脚本一样，异步会导致脚本下载而不会阻止 HTML 解析器，并尽快执行。与常规脚本不同，异步还可以在内联模块上工作。 与异步一样，脚本可能不会按照它们在 DOM 中出现的顺序执行。 浏览器问题：** Firefox 不支持嵌入式模块脚本（问题）上的异步。已在 Firefox 59 中修复！ 模块仅执行一次12345678910&lt;!-- 1.mjs 只执行一次 --&gt;&lt;script type=\"module\" src=\"1.mjs\"&gt;&lt;/script&gt;&lt;script type=\"module\" src=\"1.mjs\"&gt;&lt;/script&gt;&lt;script type=\"module\"&gt; import \"./1.mjs\";&lt;/script&gt;&lt;!-- 普通的脚本会多次执行 --&gt;&lt;script src=\"2.js\"&gt;&lt;/script&gt;&lt;script src=\"2.js\"&gt;&lt;/script&gt; 点击查看 Demo 演示 如果您了解 ES 模块，就会知道可以多次导入它们，但是它们只能执行一次。嗯，同样适用于 HTML 中的脚本模块-特定 URL 的模块脚本每页仅执行一次。 浏览器问题：** Edge 多次执行模块。已在 Edge 17 中修复！ CORS123456789101112&lt;!-- 这将不会执行，因为它无法通过CORS检查 --&gt;&lt;script type=\"module\" src=\"https://….now.sh/no-cors\"&gt;&lt;/script&gt;&lt;!-- 这将不会执行，因为其中一个导入未通过CORS检查 --&gt;&lt;script type=\"module\"&gt; import 'https://….now.sh/no-cors'; addTextToBody(\"This will not execute.\");&lt;/script&gt;&lt;!-- 这将在通过CORS检查后执行 --&gt;&lt;script type=\"module\" src=\"https://….now.sh/cors\"&gt;&lt;/script&gt; 点击查看 Demo 演示 *_与常规脚本不同，模块脚本（及其导入）是通过 CORS 获取的。这意味着跨域模块脚本必须返回有效的 CORS 标头，例如 Access-Control-Allow-Origin：_。 浏览器问题：** Firefox 无法加载演示页面（问题）。已在 Firefox 59 中修复！ Edge 加载没有 CORS 标头（问题）的模块脚本。已在 Edge 16 中修复！ 默认情况下的凭据点击查看 Demo 演示**如果请求来自同一来源，则大多数基于 CORS 的 API 都会发送凭据（Cookie 等），但是一段时间以来，fetch() 和模块脚本是例外。但是，这一切都改变了，现在 fetch 和模块脚本的行为与其他基于 CORS 的 API 相同。 但是，这意味着您将遇到三种令人兴奋的浏览器支持： 默认情况下，旧版浏览器违反当时的规范，将凭据发送到同源 URL。 当时遵循规范的浏览器，默认情况下未将凭据发送到同源 URL。 遵循新规范的新浏览器，默认情况下会将凭据发送到同源 URL。 如果遇到此问题，则可以在遵循旧规范的任何浏览器中添加 crossorigin 属性，该属性将向相同来源的请求而非交叉来源的请求(交叉来源的请求即为跨域请求)添加凭据。如果浏览器遵循新规范，它不会执行任何操作，因此可以安全使用。 1234567891011121314&lt;!-- 使用凭证（Cookie等）获取 --&gt;&lt;script src=\"1.js\"&gt;&lt;/script&gt;&lt;!-- 使用凭证获取，但遵循旧规范的旧浏览器除外 --&gt;&lt;script type=\"module\" src=\"1.mjs\"&gt;&lt;/script&gt;&lt;!-- 在遵循新旧规范的浏览器中使用凭据获取 --&gt;&lt;script type=\"module\" crossorigin src=\"1.mjs\"&gt;&lt;/script&gt;&lt;!-- 无需凭证即可获取 --&gt;&lt;script type=\"module\" crossorigin src=\"https://other-origin/1.mjs\"&gt;&lt;/script&gt;&lt;!-- 使用凭证获取 --&gt;&lt;script type=\"module\" crossorigin=\"use-credentials\" src=\"https://other-origin/1.mjs\"&gt;&lt;/script&gt; Mime-types与常规脚本不同，模块脚本必须使用有效的 JavaScript MIME 类型之一提供，否则它们将不会执行。HTML 标准建议使用 text/javascript。 点击查看 Demo 演示**浏览器问题： Edge 执行具有无效 MIME 类型（问题）的脚本。 到目前为止，这就是我所学到的。 性能建议，动态导入等！查看有关 Web 基础原理知识的文章，以深入了解模块的用法。","link":"/2020/03/06/yuque/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%20ECMAScript%E6%A8%A1%E5%9D%97/"},{"title":"类组件和函数组件","text":"参考：https://zhuanlan.zhihu.com/p/62767474 原先主要一个区别就是函数组件没有 state 和生命周期，而在 hook 引入之后，基本就没啥区别了。 现在主要的区别就是函数组件会捕获 render 内部的状态。 具体参考上述文章。","link":"/2020/04/21/yuque/%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6/"},{"title":"组件库实现支持按需加载","text":"在此之前，我们首先简单了解一下 Tree shaking。 根据 webpack 文档解释：Tree shaking 是 JavaScript 上下文中常用于消除死代码的术语。它依赖于 ES2015 模块语法的静态结构，即导入和导出。名称和概念已被 ES2015 模块捆绑器汇总所普及。 具体例子和介绍可见：https://webpack.js.org/guides/tree-shaking/ 简单来说，就是通过在 package.json 配置 sideEffects 属性来开启 Tree shaking。 他的作用主要就是为了剔除不必要的代码。 而当组件库支持按需加载作用也是类似，所谓按需加载，意为当我需要你的时候再去加载对应的模块、不要的时候就不加载。 参考 Ant Design 和 element-ui 库，你会发现他们都是通过 babel-plugin-import 或者 babel-plugin-component 来实现组件库的按需加载。(由于原先看 Ant Design 的实现过于复杂，他们是自己写了一个打包的脚本之类的工具来实现打包，所以这边借助 babel-plugin-component 来分析，貌似 4.x 的 Ant Desigin 实现的方式又有所不同了) 根据 babel-plugin-component 文档你会发现，其实他就是一个 babel 的插件，当你根据文档进行相关配置后，他会通过 ast 分析，将如下代码： 1import { Button } from \"components\"; 解析为如下： 12var button = require(\"components/lib/button\");require(\"components/lib/button/style.css\"); 那么我们就得将自己的组件库的打包方式打包成支持 babel-plugin-component 解析的路径的格式了。 然后再在使用该组件库的项目中对其进行 babel-plugin-component 相关的配置即可。 这里我们参考 element-ui 打包的方式，你可以看到主要就是：https://github.com/ElemeFE/element/blob/dev/components.json 这个 components.json 就是关键，然后再去看：https://github.com/ElemeFE/element/blob/dev/build/webpack.component.js 然后，开始编写我的组件库的打包配置： https://github.com/Spencer17x/fiora-ui-react/blob/master/components.json https://github.com/Spencer17x/fiora-ui-react/blob/master/webpack.components.js 然后，使用该库的时候需要在你的项目中配置 babel-plugin-component 的配置如下即可： 1234567891011[ \"component\", { libraryName: \"fiora-ui-react\", styleLibrary: { name: \"css\", base: false, // no base.css file path: \"[module].css\", }, },]; 注意：我这里打包出来的目录下其实是打包到库的 dist 目录下的，正常配置应该如下： 123456789101112[ \"component\", { libraryName: \"fiora-ui-react\", styleLibrary: { name: \"css\", base: false, // no base.css file path: \"[module].css\", }, libDir: \"dist/lib\", },]; 但是由于我在 ci 里配置了如下命令： 123cp package.json README.md ./distcd distnpm publish --access public 所以在发包之前它会首先 cd 到 dist 目录下，然后进行 publish 发包。然后由于 libDir 默认为 lib，所以最终配置如下即可： 1234567891011[ \"component\", { libraryName: \"fiora-ui-react\", styleLibrary: { name: \"css\", base: false, // no base.css file path: \"[module].css\", }, },]; 配置之后，那么该组件库就支持了按需加载。 总的来说，就是首先将你的组件库打包的目录格式打包成支持插件可以解析的结构，再通过插件配置即可。 拓展：可以看下 rollup 打包方式，据说效果更佳，一般来说组件库或者框架需要支持 tree shaking 的话使用 rollup 是更佳的方式，貌似 vue3 就是放弃了 webpack，采用了 rollup。","link":"/2020/03/24/yuque/%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AE%9E%E7%8E%B0%E6%94%AF%E6%8C%81%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD/"},{"title":"给第三方库添加d.ts类型声明","text":"有些第三方库是用 js 写的，没有类型声明文件，有时候在使用 ts 编写项目的时候，如果 tsconfig.json 配置添加： 12345{ \"compilerOptions\": { \"noImplicitAny\": true }} 添加之后，你在开发 ts 项目的时候 ide 会报错提示如下：由于没有@types/xxx 的库，所有得自己编写 d.ts 文件或者提 pr 到DefinitelyTyped的库。 接下来我们就通过自己在该项目下编写 d.ts 文件来解决这个问题。 根据提示，首先创建一个 xxx.d.ts 文件如下： 12345declare module 'koa-parameter' { import * as Koa from 'koa'; const context: (app: Koa, translate?: Function) =&gt; Promise&lt;void&gt;; export = context;} 然后将其放入到根目录 typing 目录下。 并在 tsconfig.json 中添加配置： 12345{ \"include\": [ \"./typings\" ]} 结果，ide 不报错了，终端使用 ts-node 运行还是报错：后经搜索，还需修改 tsconfig.json 配置 baseUrl 和 paths： 12345678910{ \"compilerOptions\": { \"baseUrl\": \".\", \"paths\": { \"koa-parameter\": [ \"./typings/koa-parameter\" ] } }} 并将前面写的 xxx.d.ts 文件放入对应目录下即可。 参考： https://github.com/TypeStrong/ts-node/issues/683 https://github.com/TypeStrong/ts-node#help-my-types-are-missing","link":"/2020/06/27/yuque/%E7%BB%99%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%B7%BB%E5%8A%A0d.ts%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E/"},{"title":"自定义Hook","text":"","link":"/2019/12/01/yuque/%E8%87%AA%E5%AE%9A%E4%B9%89Hook/"},{"title":"读YDKJS","text":"","link":"/2020/07/17/yuque/%E8%AF%BBYDKJS/"},{"title":"递归和迭代","text":"","link":"/2020/02/23/yuque/%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3/"},{"title":"配置修改注释风格","text":"参考：https://segmentfault.com/a/1190000021077778，https://segmentfault.com/q/1010000005156265 安装 webstorm，当你用快捷键(command/ctrl + /)格式化代码的时候它格式的效果是如下所示空出很多：你需要点击左上角(我的系统是 macos 的，其他系统请自行对照)WebStorm -&gt; Preferences -&gt; Editor -&gt; Code Style -&gt; html -&gt; Code Generation 下进行修改。如下图所示：即可修改 html 注释的风格了。 js 的话如下所示：自行根据英文调整哈。","link":"/2020/05/10/yuque/%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9%E6%B3%A8%E9%87%8A%E9%A3%8E%E6%A0%BC/"}],"tags":[{"name":"未完成","slug":"未完成","link":"/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"}],"categories":[{"name":"读YDKJS","slug":"读YDKJS","link":"/categories/%E8%AF%BBYDKJS/"}]}